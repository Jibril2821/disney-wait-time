<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" type="image/jpeg" href="TDR.jpg">
    <title>待ち時間履歴ビューア</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            overflow-x: hidden;
        }

        body {
            font-family: 'Segoe UI', 'Hiragino Sans', 'Meiryo', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #fff;
            padding: 20px;
            overflow-x: hidden;
        }

        /* 画面全体ローディング用オーバーレイ（履歴画面用） */
        #loadingOverlay {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at top, rgba(255,255,255,0.08), transparent),
                        linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            color: #fff;
        }

        #loadingOverlay.hidden {
            display: none;
        }

        .loading-overlay-content {
            text-align: center;
        }

        .loading-overlay-image {
            width: 140px;
            max-width: 60vw;
            height: auto;
            display: block;
            margin: 0 auto 16px;
            animation: loading-bounce 1.2s ease-in-out infinite;
            transform-origin: center bottom;
        }

        .loading-overlay-text {
            font-size: 0.95rem;
            color: rgba(255,255,255,0.85);
            letter-spacing: 0.05em;
        }

        @keyframes loading-bounce {
            0%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-24px);
            }
            60% {
                transform: translateY(6px);
            }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            min-width: 0;
            overflow-x: hidden;
        }

        header {
            text-align: center;
            padding: 30px 20px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            margin-bottom: 30px;
            position: relative;
        }

        .header-top-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .header-top-row2 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-park-row-history {
            display: flex;
            gap: 10px;
            margin-left: 12px;
        }

        /* ランド／シー切り替えボタン（リアルタイム画面と同じデザイン） */
        .park-switch-btn {
            padding: 10px 18px;
            border: none;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .park-switch-btn.land {
            background: linear-gradient(135deg, rgba(233,30,99,0.25) 0%, rgba(156,39,176,0.25) 100%);
            border: 2px solid rgba(233,30,99,0.4);
            color: #fff;
        }

        .park-switch-btn.land:hover {
            border-color: #e91e63;
            box-shadow: 0 4px 15px rgba(233,30,99,0.3);
        }

        .park-switch-btn.land.active {
            background: linear-gradient(135deg, #e91e63, #9c27b0);
            border-color: #e91e63;
        }

        .park-switch-btn.sea {
            background: linear-gradient(135deg, rgba(33,150,243,0.25) 0%, rgba(0,188,212,0.25) 100%);
            border: 2px solid rgba(33,150,243,0.4);
            color: #fff;
        }

        .park-switch-btn.sea:hover {
            border-color: #2196f3;
            box-shadow: 0 4px 15px rgba(33,150,243,0.3);
        }

        .park-switch-btn.sea.active {
            background: linear-gradient(135deg, #2196f3, #00bcd4);
            border-color: #2196f3;
        }

        .back-btn,
        .compare-header-btn {
            box-sizing: border-box;
            min-height: 44px;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            text-decoration: none;
        }
        .back-btn {
            background: rgba(255,255,255,0.1);
        }
        .back-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .back-btn-icon {
            margin-right: 6px;
            display: none; /* PC ではアイコン非表示 */
        }
        /* 戻るテキストの表示切り替え（PC/スマホ） */
        .back-btn-text-desktop {
            display: inline;
        }
        .back-btn-text-mobile {
            display: none;
        }

        .compare-header-btn {
            padding-left: 16px;
            padding-right: 16px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        /* ヘッダーのボタン内アイコン（絵文字）が iOS で縦長にならないように共通制御 */
        .header-btn-emoji {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            line-height: 1;
            width: 1.4em;
            height: 1.4em;
        }
        .header-btn-text {
            font-size: 0.95em;
        }
        .header-btn-line {
            display: inline;
        }
        #compareBtn {
            background: linear-gradient(135deg, rgba(78,205,196,0.3), rgba(68,160,141,0.3));
            border: none;
        }
        #compareBtn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(78,205,196,0.5), rgba(68,160,141,0.5));
        }
        #weekendWeekdayBtn {
            background: linear-gradient(135deg, rgba(249,202,36,0.3), rgba(243,156,18,0.3));
            border: none;
        }
        #weekendWeekdayBtn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(249,202,36,0.45), rgba(243,156,18,0.45));
        }
        #eventManageBtn {
            background: linear-gradient(135deg, rgba(156,39,176,0.3), rgba(123,31,162,0.3));
            border: none;
        }
        #eventManageBtn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(156,39,176,0.45), rgba(123,31,162,0.45));
        }
        .compare-header-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 10px;
        }

        h1 .title-text {
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .park-name {
            color: #a0a0a0;
            margin-top: 10px;
            font-size: 1.1rem;
        }

        #content {
            min-width: 0;
            overflow-x: hidden;
        }

        .controls {
            margin-bottom: 30px;
            min-width: 0;
        }

        .controls-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            min-height: 44px;
        }

        .controls-back-btn {
            padding: 10px 20px;
            min-height: 44px;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .controls-back-btn:hover {
            background: rgba(255,255,255,0.2);
        }

        .controls-center {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .controls-center .period-tabs {
            flex-shrink: 0;
        }

        .controls-center select {
            flex-shrink: 0;
            min-height: 44px;
        }

        @media (min-width: 769px) {
            .controls-row {
                display: grid;
                grid-template-columns: auto 1fr;
                grid-template-rows: auto;
                gap: 16px;
                align-items: center;
                justify-content: center;
                max-width: max-content;
                margin: 0 auto;
            }
            .controls-back-btn {
                grid-column: 1;
                grid-row: 1;
            }
            .controls-center {
                grid-column: 2;
                grid-row: 1;
                flex: 0;
                justify-content: center;
                gap: 0;
                flex-wrap: nowrap;
            }
            .controls-center select {
                margin-left: 8px; /* 期間タブと日付選択が少し離れつつまとまって見える程度に調整 */
                height: 44px;      /* 期間タブと高さを揃える */
                padding-top: 10px;
                padding-bottom: 10px;
            }
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.3s ease;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78,205,196,0.4);
        }

        select {
            padding: 12px 20px;
            border: none;
            border-radius: 30px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
            outline: none;
            min-width: 200px;
        }

        select option {
            background: #1a1a2e;
            color: #fff;
        }

        .ride-search-input {
            padding: 10px 16px;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.9rem;
            outline: none;
            min-width: 160px;
        }

        .ride-search-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        /* 期間選択タブ */
        .period-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            background: rgba(255,255,255,0.05);
            padding: 5px;
            border-radius: 30px;
            min-width: 0;
            width: auto;              /* 中身の幅にフィット */
            box-sizing: border-box;
            margin: 0 auto;           /* 行の中央に配置 */
            justify-content: center;  /* タブ自体も中央寄せ */
        }

        .period-tab {
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.3s ease;
            background: transparent;
            color: #a0a0a0;
            flex-shrink: 0;
        }

        .period-tab:hover {
            color: #fff;
        }

        .period-tab.active {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
        }

        .chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            min-width: 0;
        }

        .chart-title {
            font-size: 1.3rem;
            margin-bottom: 20px;
            text-align: center;
        }

        .data-info {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .data-info h3 {
            margin-bottom: 15px;
            color: #4ecdc4;
        }

        .data-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .data-info-item {
            text-align: center;
        }

        .data-info-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: #f9ca24;
        }

        .data-info-label {
            font-size: 0.85rem;
            color: #a0a0a0;
        }

        .data-info-best-times {
            margin-top: 14px;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(249, 202, 36, 0.12);
            border: 1px solid rgba(249, 202, 36, 0.25);
            font-size: 0.9rem;
        }

        .data-info-best-times-title {
            font-weight: 600;
            color: #f9ca24;
            margin-bottom: 4px;
        }

        .data-info-best-times-value {
            color: #fff;
        }

        .correlation-section {
            margin-top: 14px;
            padding: 14px 16px;
            border-radius: 12px;
            background: rgba(78, 205, 196, 0.12);
            border: 1px solid rgba(78, 205, 196, 0.25);
            font-size: 0.9rem;
        }

        .correlation-section-title {
            font-weight: 600;
            color: #4ecdc4;
            margin-bottom: 8px;
            font-size: 0.95rem;
        }

        .correlation-section-description {
            color: rgba(255, 255, 255, 0.85);
            margin-bottom: 12px;
            line-height: 1.5;
        }

        .correlation-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .correlation-item {
            padding: 8px 14px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.2s ease;
        }

        .correlation-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-1px);
        }

        .correlation-item.strong {
            background: rgba(78, 205, 196, 0.2);
            border-color: rgba(78, 205, 196, 0.4);
        }

        .correlation-item.moderate {
            background: rgba(78, 205, 196, 0.12);
            border-color: rgba(78, 205, 196, 0.3);
        }

        .correlation-ride-name {
            color: #fff;
            font-weight: 500;
        }

        /* 旧ローディングオーバーレイ（.loading）は使用しない */

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .no-data {
            text-align: center;
            padding: 60px 20px;
            color: #a0a0a0;
        }

        .no-data h2 {
            margin-bottom: 20px;
            color: #fff;
        }

        .error {
            text-align: center;
            padding: 40px 20px;
            background: rgba(255,107,107,0.1);
            border-radius: 20px;
            color: #ff6b6b;
        }

        /* 全アトラクション一覧 */
        .rides-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(100%, 280px), 1fr));
            gap: 15px;
            margin-top: 20px;
            min-width: 0;
        }

        .ride-card {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .ride-card:hover {
            transform: translateY(-3px);
            background: rgba(255,255,255,0.08);
            border-color: rgba(78,205,196,0.5);
        }

        .ride-card.closed {
            opacity: 0.5;
        }

        .ride-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .ride-card-name {
            font-size: 0.95rem;
            font-weight: 600;
            flex: 1;
            margin-right: 10px;
        }

        .ride-card-fav-btn {
            border: none;
            background: transparent;
            color: #888;
            cursor: pointer;
            font-size: 1.1rem;
            padding: 0;
            margin-left: 6px;
            transition: color 0.2s ease, transform 0.1s ease;
        }

        .ride-card-fav-btn:hover {
            color: #ffd86b;
            transform: scale(1.1);
        }

        .ride-card-fav-btn.active {
            color: #ffd86b;
        }

        .ride-card-status {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            white-space: nowrap;
        }

        .ride-card-status.open {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .ride-card-status.closed {
            background: rgba(255,255,255,0.2);
            color: #a0a0a0;
        }

        .ride-card-wait {
            display: flex;
            align-items: baseline;
            gap: 5px;
        }

        .ride-card-wait-value {
            font-size: 2rem;
            font-weight: 700;
        }

        .ride-card-wait-unit {
            font-size: 0.9rem;
            color: #a0a0a0;
        }

        .ride-card-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        .ride-card-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .ride-card-stat-label {
            font-size: 1rem;
            color: #a0a0a0;
        }

        .ride-card-stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            line-height: 1;
        }

        .ride-card-stat-value .unit {
            font-size: 1rem;
            font-weight: 400;
            color: #a0a0a0;
            margin-left: 2px;
        }

        /* .ride-card-stat-value.wait-* のスタイルは park-data.js から動的に注入されます */

        .ride-card-no-data {
            color: #a0a0a0;
            font-size: 0.9rem;
            margin-top: 10px;
            text-align: center;
        }

        /* 過去○週間スパークライン（一覧カード・詳細） */
        .sparkline-wrap {
            margin-top: 10px;
            padding: 8px 0;
            border-top: 1px solid rgba(255,255,255,0.08);
        }
        .sparkline-wrap .sparkline-title {
            font-size: 0.7rem;
            color: #a0a0a0;
            margin-bottom: 4px;
        }
        .sparkline-wrap .sparkline-canvas-wrap {
            position: relative;
            width: 100%;
            height: 36px;
        }
        .sparkline-wrap .sparkline-canvas-wrap canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }
        .sparkline-detail {
            background: rgba(255,255,255,0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 25px;
        }
        .sparkline-detail .sparkline-title {
            font-size: 0.95rem;
            color: #4ecdc4;
            margin-bottom: 12px;
        }
        .sparkline-detail .sparkline-canvas-wrap {
            height: 80px;
        }

        /* エリアセクション */
        .area-section {
            margin-bottom: 40px;
        }

        .area-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
            padding: 15px 25px;
            border-radius: 15px;
            background: rgba(255,255,255,0.05);
        }

        .area-header-icon {
            font-size: 2rem;
        }

        .area-header-info {
            flex: 1;
        }

        .area-header-name {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .area-header-stats {
            font-size: 0.85rem;
            color: #a0a0a0;
        }

        /* TDL エリアカラー（セクション用） */
        .area-worldbazaar .area-header { border-left: 4px solid #e74c3c; }
        .area-adventureland .area-header { border-left: 4px solid #27ae60; }
        .area-westernland .area-header { border-left: 4px solid #d35400; }
        .area-crittercountry .area-header { border-left: 4px solid #8e44ad; }
        .area-fantasyland .area-header { border-left: 4px solid #e91e63; }
        .area-toontown .area-header { border-left: 4px solid #f39c12; }
        .area-tomorrowland .area-header { border-left: 4px solid #3498db; }

        /* TDS エリアカラー（セクション用） */
        .area-mediterranean .area-header { border-left: 4px solid #8e44ad; }
        .area-americanwaterfront .area-header { border-left: 4px solid #e74c3c; }
        .area-portdiscovery .area-header { border-left: 4px solid #3498db; }
        .area-lostriverdelta .area-header { border-left: 4px solid #27ae60; }
        .area-arabiancoast .area-header { border-left: 4px solid #f39c12; }
        .area-mermaidlagoon .area-header { border-left: 4px solid #e91e63; }
        .area-mysteriousisland .area-header { border-left: 4px solid #1abc9c; }
        .area-fantasysprings .area-header { border-left: 4px solid #9b59b6; }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        th {
            background: rgba(255,255,255,0.05);
            font-weight: 600;
            color: #4ecdc4;
        }

        tr:hover {
            background: rgba(255,255,255,0.03);
        }

        /* .wait-* 基本スタイルは park-data.js から動的に注入されます */

        .back-to-list-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .back-to-list-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }

        /* エリアタブ（PC: 表示幅から計算して一行に収める） */
        .area-tabs {
            display: flex;
            flex-wrap: nowrap;
            gap: 10px;
            margin-bottom: 25px;
            width: 100%;
        }

        .area-tab {
            flex: 1 1 0;
            min-width: 0;
            padding: 12px 8px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: clamp(0.7rem, 1.2vw, 0.85rem);
            font-weight: 600;
            transition: all 0.3s ease;
            background: rgba(255,255,255,0.08);
            color: #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            text-align: center;
            overflow: hidden;
        }

        .area-tab span:not(.area-icon):not(.area-count) {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .area-tab:hover {
            background: rgba(255,255,255,0.15);
            transform: translateY(-2px);
        }

        .area-tab.active {
            color: #fff;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
        }

        .area-tab .area-icon {
            font-size: 1rem;
        }

        .area-tab .area-count {
            background: rgba(255,255,255,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }

        /* エリア絞り込みラッパー（スマホで折りたたみ） */
        .area-filter-wrapper {
            margin-bottom: 25px;
        }
        .area-filter-toggle {
            display: none;
            width: 100%;
            padding: 12px 16px;
            border: none;
            border-radius: 12px;
            background: rgba(255,255,255,0.08);
            color: #ccc;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            text-align: left;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            transition: background 0.2s;
        }
        .area-filter-toggle:hover {
            background: rgba(255,255,255,0.12);
        }
        .area-filter-chevron {
            display: inline-block;
            transition: transform 0.25s ease;
            font-size: 0.75rem;
        }
        .area-filter-wrapper:not(.collapsed) .area-filter-chevron {
            transform: rotate(180deg);
        }
        .area-tabs-body {
            margin-top: 0;
        }

        /* TDL エリアカラー */
        .area-tab.area-worldbazaar.active { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .area-tab.area-adventureland.active { background: linear-gradient(135deg, #27ae60, #1e8449); }
        .area-tab.area-westernland.active { background: linear-gradient(135deg, #d35400, #a04000); }
        .area-tab.area-crittercountry.active { background: linear-gradient(135deg, #8e44ad, #6c3483); }
        .area-tab.area-fantasyland.active { background: linear-gradient(135deg, #e91e63, #c2185b); }
        .area-tab.area-toontown.active { background: linear-gradient(135deg, #f39c12, #d68910); }
        .area-tab.area-tomorrowland.active { background: linear-gradient(135deg, #3498db, #2874a6); }

        /* TDS エリアカラー */
        .area-tab.area-mediterranean.active { background: linear-gradient(135deg, #8e44ad, #6c3483); }
        .area-tab.area-americanwaterfront.active { background: linear-gradient(135deg, #e74c3c, #c0392b); }
        .area-tab.area-portdiscovery.active { background: linear-gradient(135deg, #3498db, #2874a6); }
        .area-tab.area-lostriverdelta.active { background: linear-gradient(135deg, #27ae60, #1e8449); }
        .area-tab.area-arabiancoast.active { background: linear-gradient(135deg, #f39c12, #d68910); }
        .area-tab.area-mermaidlagoon.active { background: linear-gradient(135deg, #e91e63, #c2185b); }
        .area-tab.area-mysteriousisland.active { background: linear-gradient(135deg, #1abc9c, #16a085); }
        .area-tab.area-fantasysprings.active { background: linear-gradient(135deg, #9b59b6, #8e44ad); }

        .overview-chart-container {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            max-width: 100%;
            overflow-x: auto;
        }

        .overview-chart-container canvas {
            max-height: 400px;
            max-width: 100%;
        }

        .visit-summary {
            margin-bottom: 16px;
            padding: 10px 14px;
            border-radius: 12px;
            background: rgba(0,0,0,0.25);
            font-size: 0.85rem;
            color: #ddd;
        }

        .visit-summary-title {
            font-weight: 600;
            margin-bottom: 6px;
            color: #f9ca24;
        }

        .visit-summary-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 16px;
        }

        .visit-summary-item {
            display: flex;
            align-items: baseline;
            gap: 4px;
        }

        .visit-summary-rank {
            font-weight: 600;
            color: #ffd86b;
        }

        /* 比較モード（詳細グラフ） */
        .compare-toolbar {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(255,255,255,0.04);
            font-size: 0.8rem;
        }

        .compare-toolbar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .compare-toolbar-title {
            font-weight: 600;
            color: #f9ca24;
        }

        .compare-select {
            padding: 6px 10px;
            border-radius: 10px;
            border: none;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 0.8rem;
            min-width: 200px;
        }

        .compare-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 6px;
        }

        .compare-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            border-radius: 999px;
            background: rgba(255,255,255,0.1);
            font-size: 0.75rem;
        }

        .compare-chip button {
            border: none;
            background: transparent;
            color: #ffd86b;
            cursor: pointer;
            font-size: 0.8rem;
            padding: 0;
        }

        /* 混雑ヒートマップ */
        .heatmap-container {
            margin-bottom: 24px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 16px 18px;
        }

        .heatmap-title {
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .heatmap-note {
            font-size: 0.75rem;
            color: #a0a0a0;
            margin-bottom: 8px;
        }

        .heatmap-table-wrapper {
            overflow-x: auto;
        }

        .heatmap-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .heatmap-table th,
        .heatmap-table td {
            padding: 4px 6px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            border-right: 1px solid rgba(255,255,255,0.04);
            text-align: center;
            white-space: nowrap;
        }

        .heatmap-table th:first-child,
        .heatmap-table td:first-child {
            position: sticky;
            left: 0;
            background: rgba(15, 23, 42, 0.95);
            z-index: 1;
            text-align: left;
        }

        .heatmap-header {
            background: rgba(255,255,255,0.04);
            font-size: 0.7rem;
            color: #cccccc;
        }

        .heatmap-ride-name {
            max-width: 160px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* スマホ表示時: アトラクション名の背景を不透明にしてヒートマップの色が透けて見えないようにする */
        @media (max-width: 768px) {
            .heatmap-table th:first-child,
            .heatmap-table td:first-child {
                background: #0f172a;
            }
        }

        .heatmap-cell {
            min-width: 30px;
            font-size: 0.7rem;
        }

        .heat-none {
            background: rgba(0,0,0,0.1);
            color: #666;
        }

        /* .heatmap-cell.wait-* スタイルは park-data.js から動的に注入されます */

        /* 曜日×時間帯マトリクス */
        .matrix-best-cell {
            outline: 2px solid #f9ca24;
            outline-offset: -2px;
            position: relative;
        }

        .matrix-day-label {
            min-width: 30px;
            font-weight: 600;
        }

        /* 混雑カレンダー（月・週・年ビュー用） */
        .calendar-container {
            margin-bottom: 24px;
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 16px 18px;
            max-width: 100%;
            min-width: 0;
            overflow-x: auto;
        }

        .calendar-title {
            font-size: 1rem;
            margin-bottom: 6px;
        }

        .calendar-note {
            font-size: 0.8rem;
            color: #a0a0a0;
            margin-bottom: 10px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, minmax(0, 1fr));
            gap: 4px;
            font-size: 0.8rem;
            min-width: 0;
        }

        .calendar-weekday {
            text-align: center;
            color: #a0a0a0;
            padding: 4px 0;
        }

        .calendar-day {
            min-height: 46px;
            border-radius: 10px;
            padding: 4px 6px;
            background: rgba(15,23,42,0.85);
            border: 1px solid rgba(255,255,255,0.06);
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .calendar-day:hover:not(.disabled) {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
            opacity: 0.9;
        }

        .calendar-day.disabled {
            cursor: default;
            opacity: 0.3;
            background: rgba(15,23,42,0.6);
        }

        .calendar-day.disabled:hover {
            transform: none;
            box-shadow: none;
            background: rgba(15,23,42,0.6);
        }

        .calendar-day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2px;
        }

        .calendar-day-date {
            font-weight: 600;
            font-size: 0.8rem;
        }

        .calendar-day-weekday {
            font-size: 0.7rem;
            color: #a0a0a0;
        }

        .calendar-day-value {
            font-size: 0.8rem;
        }

        .calendar-day-event-badge {
            font-size: 0.7rem;
            margin-left: 2px;
        }

        /* .calendar-day.wait-* スタイルは park-data.js から動的に注入されます */

        /* 年ビュー用のカレンダーラッパー */
        .year-calendars-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(min(260px, 100%), 1fr));
            gap: 16px;
            min-width: 0;
            max-width: 100%;
        }

        .year-calendar-month {
            background: rgba(255,255,255,0.02);
            border-radius: 12px;
            padding: 12px;
            min-width: 0;
            overflow: hidden;
        }

        .year-calendar-month-title {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 8px;
            text-align: center;
            color: #a0a0a0;
            word-break: keep-all;
        }

        /* 年ビュー内のグリッド・セル（狭いのでコンパクトに） */
        .year-calendar-grid {
            width: 100%;
            font-size: 0.7rem;
        }

        .year-calendar-grid .calendar-weekday {
            padding: 2px 0;
            font-size: 0.65rem;
        }

        .year-calendar-grid .calendar-day {
            min-height: 36px;
            padding: 2px 4px;
        }

        .year-calendar-grid .calendar-day-date {
            font-size: 0.7rem;
        }

        .year-calendar-grid .calendar-day-weekday {
            font-size: 0.6rem;
        }

        .year-calendar-grid .calendar-day-value {
            font-size: 0.65rem;
        }

        .calendar-cell-empty {
            min-height: 1px;
        }

        .chart-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
            color: #a0a0a0;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 12px;
            transition: all 0.2s ease;
        }

        .legend-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .legend-item.hidden {
            opacity: 0.4;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        .search-fav-row {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 15px;
            min-width: 0;
        }

        .favorites-toolbar {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 0;
            gap: 8px;
        }

        .ride-search-wrap {
            margin-bottom: 0;
        }
        .ride-search-wrap .ride-search-input {
            width: 100%;
            box-sizing: border-box;
        }

        .fav-toggle-btn {
            padding: 8px 14px;
            border-radius: 16px;
            border: none;
            background: rgba(255,255,255,0.06);
            color: #ffdd88;
            font-size: 0.85rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            transition: background 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
        }

        .fav-toggle-btn:hover {
            background: rgba(255,255,255,0.12);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .fav-toggle-btn.active {
            background: linear-gradient(135deg, #f6d365, #fda085);
            color: #4b2c20;
            box-shadow: 0 3px 10px rgba(0,0,0,0.4);
        }

        /* 前回の来園日と比較 */
        .compare-section {
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 30px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .compare-section-title {
            font-size: 1.25rem;
            margin-bottom: 16px;
            color: #4ecdc4;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .compare-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .compare-controls label {
            color: #a0a0a0;
            font-size: 0.9rem;
        }

        .compare-controls select {
            padding: 10px 16px;
            border-radius: 25px;
            background: rgba(255,255,255,0.1);
            color: #fff;
            border: none;
            font-size: 0.9rem;
            cursor: pointer;
            min-width: 180px;
        }

        .compare-controls select option {
            background: #1a1a2e;
            color: #fff;
        }

        .compare-btn {
            padding: 10px 24px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .compare-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(78,205,196,0.4);
        }

        .compare-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .compare-note {
            font-size: 0.8rem;
            color: #a0a0a0;
            margin: -8px 0 12px 0;
        }

        .compare-summary {
            padding: 16px 20px;
            border-radius: 12px;
            margin-bottom: 16px;
            font-size: 1.05rem;
            text-align: center;
        }

        .compare-summary.less {
            background: rgba(78,205,196,0.15);
            border: 1px solid rgba(78,205,196,0.4);
            color: #4ecdc4;
        }

        .compare-summary.more {
            background: rgba(255,107,107,0.15);
            border: 1px solid rgba(255,107,107,0.4);
            color: #ff6b6b;
        }

        .compare-summary.same {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            color: #a0a0a0;
        }

        .compare-table-wrapper {
            overflow-x: auto;
            border-radius: 12px;
            background: rgba(0,0,0,0.2);
        }

        .compare-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .compare-table th,
        .compare-table td {
            padding: 10px 12px;
            text-align: left;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }

        .compare-table th {
            background: rgba(255,255,255,0.06);
            color: #4ecdc4;
            font-weight: 600;
        }

        .compare-table td.compare-diff-less {
            color: #4ecdc4;
            font-weight: 600;
        }

        .compare-table td.compare-diff-more {
            color: #ff6b6b;
            font-weight: 600;
        }

        .compare-table td.compare-diff-same {
            color: #a0a0a0;
        }

        .compare-no-data {
            text-align: center;
            color: #a0a0a0;
            padding: 20px;
            font-size: 0.95rem;
        }

        /* グラフの点クリック時のポップアップ */
        .point-popup-overlay {
            position: fixed;
            inset: 0;
            background: transparent;
            z-index: 9999;
        }

        .point-popup {
            position: absolute;
            min-width: 260px;
            background: #1e2749;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px 14px;
            color: #fff;
            font-size: 0.85rem;
        }

        .point-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .point-popup-title {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .point-popup-close {
            background: transparent;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 1rem;
        }

        .point-popup-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
            overflow-x: hidden;
            margin-top: 4px;
        }

        .point-popup-item {
            width: 100%;
            text-align: left;
            border: none;
            border-radius: 8px;
            padding: 6px 14px; /* 左右に少し余裕を持たせる */
            background: rgba(255,255,255,0.04);
            color: #fff;
            font-size: 0.8rem;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .point-popup-item:hover {
            background: rgba(78,205,196,0.25);
        }

        .point-popup-item-main {
            display: flex;
            justify-content: space-between;
            align-items: center;
            white-space: nowrap;
        }

        .point-popup-item-name {
            font-weight: 600;
            white-space: nowrap;
        }

        .point-popup-item-meta {
            font-size: 0.75rem;
            color: #a0a0a0;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.5rem;
            }

            header {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* スマホ時は「リアルタイム」「ランド」「シー」を同じ行で3分割 */
            .header-top-row {
                display: grid;
                width: 100%;
                grid-template-columns: repeat(3, 1fr);
                grid-template-rows: auto auto;
                gap: 10px;
            }

            .back-btn {
                position: static;
                margin-bottom: 0;
                width: 100%;
                justify-content: center;
                padding: 8px 6px;
                font-size: 0.9rem;
                box-sizing: border-box;
                grid-column: 1;
                grid-row: 1;
                height: 64px;
                flex-direction: column;
                gap: 2px;
                border-radius: 12px;
            }
            .back-btn-icon {
                display: inline; /* スマホではアイコン表示 */
            }
            .back-btn-text-desktop {
                display: none;
            }
            .back-btn-text-mobile {
                display: inline;
            }

            .header-park-row-history {
                display: contents;
            }

            .header-park-row-history .park-switch-btn {
                width: 100%;
                min-width: 0;
                height: 64px;
                padding: 8px 6px;
                font-size: 0.8rem;
                border-radius: 12px;
                flex-direction: column;
                gap: 2px;
            }

            .header-top-row2 {
                width: 100%;
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                grid-column: 1 / -1;
                grid-row: 2;
            }

            .header-top-row2 .compare-header-btn {
                min-width: 0;
                height: 64px;
                padding: 8px 6px;
                font-size: 0.8rem;
                justify-content: center;
                align-items: center;
                flex-direction: column;
                gap: 2px;
                border-radius: 12px;
            }
            .header-top-row2 .header-btn-emoji {
                display: block;
                font-size: 1.4em;
                line-height: 1;
                flex-shrink: 0;
                height: 1.2em;
            }
            .header-top-row2 .header-btn-text {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                min-height: 2.4em;
                font-size: 0.7rem;
                font-weight: 700;
                line-height: 1.2;
                text-align: center;
            }
            .header-top-row2 .header-btn-line {
                display: block;
            }

            .controls-row {
                display: grid;
                grid-template-columns: auto 1fr;
                grid-template-rows: auto auto;
                gap: 10px;
            }
            .controls-back-btn {
                grid-column: 1;
                grid-row: 1;
            }
            .controls-center {
                display: contents;
            }
            .controls-center .period-tabs {
                grid-column: 2;
                grid-row: 1;
                min-width: 0;
                width: fit-content;
                max-width: 100%;
                justify-content: center;
                justify-self: center;
                margin: 0;
            }
            .controls-center select {
                grid-column: 1 / -1;
                grid-row: 2;
                min-width: 0;
                width: 100%;
                box-sizing: border-box;
            }

            select, .btn, .ride-search-input {
                width: 100%;
            }

            .favorites-toolbar {
                width: 100%;
                justify-content: stretch;
            }
            .favorites-toolbar .fav-toggle-btn {
                width: 100%;
                justify-content: center;
                box-sizing: border-box;
            }
            .ride-search-wrap .ride-search-input {
                width: 100%;
                box-sizing: border-box;
            }

            .area-filter-toggle {
                display: flex;
            }
            .area-filter-wrapper.collapsed .area-tabs-body {
                display: none !important;
            }
            .area-filter-wrapper .area-tabs-body {
                margin-top: 10px;
            }
            .area-tabs {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                flex-wrap: wrap;
                gap: 8px;
            }

            .area-tab {
                flex: none;
                min-width: unset;
                padding: 10px 12px;
                font-size: 0.75rem;
            }

            .rides-grid {
                grid-template-columns: 1fr;
            }

            .area-header {
                flex-direction: column;
                text-align: center;
                gap: 10px;
            }

            /* スマホ表示時は待ち時間推移グラフを非表示 */
            .overview-chart-container {
                display: none !important;
            }
            .chart-container:has(#waitTimeChart) {
                display: none !important;
            }
        }
        /* PCでは折りたたみボタン非表示・エリアタブ常時表示 */
        @media (min-width: 769px) {
            .area-filter-wrapper.collapsed .area-tabs-body {
                display: block !important;
            }
        }

        /* PC表示時: 比較・週末/平日ボタンを右寄せ / 名前で検索・お気に入りを横並びに */
        @media (min-width: 769px) {
            .header-top-row {
                justify-content: space-between;
                width: 100%;
            }
            .header-top-row2 {
                margin-left: auto;
            }
            .search-fav-row {
                flex-direction: row;
                align-items: center;
            }
            .search-fav-row .ride-search-wrap {
                flex: 1;
                min-width: 0;
            }
            .search-fav-row .favorites-toolbar {
                flex: 0 0 auto;
            }
            .search-fav-row .favorites-toolbar .fav-toggle-btn {
                width: auto;
            }
        }

        /* 前回の来園日と比較モーダル（回り順プランナーと同様） */
        .compare-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        .compare-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 20px;
            width: 100%;
            max-width: 520px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255,255,255,0.15);
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }
        .compare-modal-header {
            padding: 20px 25px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        .compare-modal-title {
            font-size: 1.3rem;
            font-weight: 700;
        }
        .compare-modal-close {
            background: rgba(255,255,255,0.1);
            border: none;
            color: #fff;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .compare-modal-close:hover {
            background: rgba(255,255,255,0.2);
        }
        .compare-modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px 25px;
        }
        .compare-modal .compare-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
        }
        .compare-modal .compare-controls label {
            width: 100%;
            font-size: 0.9rem;
            color: #ccc;
        }
        .compare-modal .compare-controls select {
            padding: 10px 14px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.08);
            color: #fff;
            font-size: 0.95rem;
            cursor: pointer;
        }
        .compare-modal .compare-run-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: opacity 0.2s;
        }
        .compare-modal .compare-run-btn:hover:not(:disabled) {
            opacity: 0.9;
        }
        .compare-modal .compare-run-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }
        .compare-modal .compare-note {
            font-size: 0.8rem;
            color: #a0a0a0;
            margin-bottom: 16px;
        }
        .compare-modal #compareResult {
            margin-top: 16px;
        }

        @media (min-width: 769px) {
            .event-manage-modal {
                max-width: 720px;
            }
            #compareOverlay .compare-modal {
                max-width: 720px;
            }
        }
        .event-manage-modal .event-manage-add { margin-bottom: 20px; }
        .event-manage-modal .event-manage-add h4,
        .event-manage-modal .event-manage-list-wrap h4 { font-size: 1rem; margin-bottom: 10px; color: #ccc; }
        .event-manage-form { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; margin-bottom: 10px; }
        .event-manage-form input[type="text"] { min-width: 140px; }
        .event-manage-form input[type="date"] { min-width: 120px; }
        .event-manage-form-dates { display: flex; align-items: center; gap: 10px; }
        .event-manage-form-sep { flex-shrink: 0; }
        @media (max-width: 768px) {
            .event-manage-modal .event-manage-form-dates {
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 8px;
                width: 100%;
                min-width: 0;
            }
            .event-manage-modal .event-manage-form-dates input {
                flex: 1;
                min-width: 0;
            }
            .event-manage-modal .event-manage-form-sep {
                flex-shrink: 0;
            }
        }
        .event-manage-list { list-style: none; }
        .event-manage-list li { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
        .event-manage-list li .event-item-label { font-weight: 600; min-width: 100px; }
        .event-manage-list li .event-item-dates { color: #a0a0a0; font-size: 0.9rem; }
        .event-manage-list li button { padding: 6px 12px; border-radius: 12px; border: none; cursor: pointer; font-size: 0.85rem; }
        .event-manage-list li .event-item-delete { margin-left: auto; background: rgba(255,100,100,0.3); color: #fff; }
        .event-item-delete:hover { background: rgba(255,100,100,0.5); }

        /* お気に入り機能用：ログイン必須モーダル（履歴画面） */
        .fav-login-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.7);
            z-index: 1100;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 20px;
            backdrop-filter: blur(5px);
        }
        .fav-login-modal {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 18px;
            width: 100%;
            max-width: 420px;
            padding: 22px 24px 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
        }
        .fav-login-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .fav-login-title span.icon {
            font-size: 1.4rem;
        }
        .fav-login-message {
            font-size: 0.9rem;
            color: #ddd;
            line-height: 1.6;
            margin-bottom: 16px;
        }
        .fav-login-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .fav-login-close-btn,
        .fav-login-go-login-btn {
            border: none;
            border-radius: 999px;
            padding: 8px 16px;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .fav-login-close-btn {
            background: rgba(255,255,255,0.08);
            color: #fff;
        }
        .fav-login-go-login-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: #fff;
            font-weight: 600;
        }
        @media (max-width: 768px) {
            .event-manage-modal .event-manage-list li {
                display: grid;
                grid-template-columns: 1fr auto;
                grid-template-rows: auto auto;
                gap: 4px 12px;
                align-items: center;
            }
            .event-manage-modal .event-manage-list li .event-item-label {
                grid-column: 1;
                grid-row: 1;
                min-width: 0;
            }
            .event-manage-modal .event-manage-list li .event-item-dates {
                grid-column: 1;
                grid-row: 2;
            }
            .event-manage-modal .event-manage-list li .event-item-delete {
                grid-column: 2;
                grid-row: 1 / span 2;
                align-self: center;
            }
        }
        .day-view-event-wrap { margin: 0 12px 10px; max-width: 100%; min-width: 0; overflow-x: hidden; }
        .day-view-event-line { margin: 10px 0; padding: 12px 14px; background: rgba(78, 205, 196, 0.08); border-radius: 12px; border-left: 4px solid rgba(78, 205, 196, 0.5); }
        .day-view-event-line .today-events-title { font-size: 0.85rem; font-weight: 700; color: #4ecdc4; margin-bottom: 10px; letter-spacing: 0.02em; }
        .day-view-event-line .today-events-list { display: flex; flex-wrap: wrap; gap: 10px; }
        .day-view-event-line .today-events-item { display: inline-flex; flex-direction: column; align-items: flex-start; gap: 4px; padding: 10px 14px; background: rgba(26, 26, 46, 0.85); border-radius: 10px; border: 1px solid rgba(78, 205, 196, 0.4); font-size: 0.9rem; color: rgba(255,255,255,0.95); min-width: 120px; }
        .day-view-event-line .today-events-item-label { font-weight: 600; }
        .day-view-event-line .today-events-item-period { font-size: 0.75rem; color: rgba(255,255,255,0.6); }
        .event-manage-list .event-manage-empty { color: #a0a0a0; list-style: none; }

        .auth-status-chip {
            padding: 10px 14px;
            border-radius: 25px;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.3);
            color: rgba(255,255,255,0.75);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-height: 44px;
            max-width: 260px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .auth-status-chip span {
            opacity: 0.9;
        }
        .auth-status-chip strong {
            font-weight: 700;
            color: #fff;
        }
        .auth-user-icon {
            font-size: 1.1rem;
        }
        .auth-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            object-fit: cover;
        }
        .auth-user-name {
            font-weight: 600;
            color: #fff;
        }
        .auth-role-badge {
            padding: 2px 6px;
            border-radius: 999px;
            font-size: 0.7rem;
            background: #ffb74d;
            color: #1a1a2e;
            font-weight: 700;
        }
        .auth-small-btn {
            padding: 10px 16px;
            border-radius: 25px;
            font-size: 0.9rem;
            border: none;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: #fff;
            background: rgba(255,255,255,0.12);
            transition: background 0.2s ease, transform 0.1s ease;
        }
        .auth-small-btn:hover {
            background: rgba(255,255,255,0.22);
            transform: translateY(-1px);
        }

        /* ログインボタン専用の強調色（履歴画面） */
        .auth-login-btn {
            background: linear-gradient(135deg, #4ecdc4, #1dd1a1);
            box-shadow: 0 0 12px rgba(78, 205, 196, 0.6);
        }
        .auth-login-btn:hover {
            background: linear-gradient(135deg, #5ff0de, #1dd1a1);
        }

        .auth-mobile-bar {
            display: none;
            /* 画面全体の横幅いっぱいに見えるように、body の padding(20px)を打ち消す */
            width: calc(100% + 40px);
            margin: 0 -20px 0 -20px;
            padding: 8px 16px 0;
            box-sizing: border-box;
            align-items: center;
            justify-content: flex-start;
            gap: 8px;
        }

        @media (max-width: 768px) {
            .auth-mobile-bar {
                display: flex;
            }
            .header-top-row2 .auth-status-chip,
            .header-top-row2 .auth-small-btn {
                display: none;
            }
        }

        /* 認証画面 */
        .auth-screen {
            min-height: 100vh;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .auth-card {
            width: 100%;
            max-width: 420px;
            background: rgba(15, 22, 40, 0.95);
            border-radius: 18px;
            padding: 28px 24px 24px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.45);
            border: 1px solid rgba(255, 255, 255, 0.08);
        }
        .auth-title {
            font-size: 1.3rem;
            margin-bottom: 0.75rem;
        }
        .auth-desc {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 1.4rem;
            line-height: 1.6;
        }
        .auth-field {
            margin-bottom: 0.9rem;
        }
        .auth-label {
            display: block;
            font-size: 0.85rem;
            margin-bottom: 0.3rem;
            color: rgba(255, 255, 255, 0.8);
        }
        .auth-input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: rgba(10, 15, 30, 0.9);
            color: #fff;
            font-size: 0.95rem;
        }
        .auth-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }
        .auth-input:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 0 1px rgba(78, 205, 196, 0.3);
        }
        .auth-actions {
            margin-top: 1.1rem;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .auth-button {
            flex: 1;
            border: none;
            border-radius: 999px;
            padding: 10px 14px;
            background: linear-gradient(135deg, #4ecdc4, #45b7d1);
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: transform 0.15s ease, box-shadow 0.15s ease, opacity 0.15s ease;
        }
        .auth-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        .auth-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            box-shadow: none;
        }
        .auth-status {
            font-size: 0.85rem;
            min-height: 1.2em;
            color: rgba(255, 255, 255, 0.75);
        }
        .auth-status.error {
            color: #ff6b6b;
        }
        .auth-status.success {
            color: #4ecdc4;
        }
        .auth-note {
            margin-top: 0.9rem;
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.55);
            line-height: 1.6;
        }
        .auth-note code {
            font-size: 0.8rem;
            background: rgba(0, 0, 0, 0.35);
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
    <script src="park-data.js"></script>
    <script src="supabase-config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="master-from-supabase.js"></script>
</head>
<body>
    <!-- 画面全体ローディングオーバーレイ -->
    <div id="loadingOverlay">
        <div class="loading-overlay-content">
            <img src="loading.jpg" alt="読み込み中" class="loading-overlay-image">
            <p class="loading-overlay-text">読み込み中です...</p>
        </div>
    </div>

    <!-- スマホ用ログイン状態バー -->
    <div class="auth-mobile-bar" id="historyAuthMobileBar">
        <div class="auth-status-chip" id="historyAuthStatusChipMobile">
            <span>未ログイン</span>
        </div>
        <button type="button" class="auth-small-btn auth-login-btn" id="historyGoogleLoginBtnMobile">
            <span>ログイン</span>
        </button>
        <button type="button" class="auth-small-btn" id="historyLogoutBtnMobile" style="display:none;">
            <span>ログアウト</span>
        </button>
    </div>

    <!-- お気に入り機能：ログイン必須モーダル（履歴画面） -->
    <div id="favLoginOverlay" class="fav-login-overlay" onclick="hideFavLoginModal()">
        <div class="fav-login-modal" onclick="event.stopPropagation()">
            <div class="fav-login-title">
                <span class="icon">🔑</span>
                <span>ログインが必要です</span>
            </div>
            <div class="fav-login-message">
                お気に入り機能を使うには、Google アカウントでログインしてください。<br>
                ログインすると、端末をまたいでお気に入りを共有できます。
            </div>
            <div class="fav-login-actions">
                <button type="button" class="fav-login-close-btn" onclick="hideFavLoginModal()">閉じる</button>
                <button type="button" class="fav-login-go-login-btn" onclick="loginFromFavModal()">ログインする</button>
            </div>
        </div>
    </div>

    <div class="container" id="historyMainContainer" style="display:none;">
        <header>
            <div class="header-top-row">
                <a href="index.html" class="back-btn"><span class="back-btn-icon">⬅️</span><span class="back-btn-text back-btn-text-desktop">リアルタイム</span><span class="back-btn-text back-btn-text-mobile">戻る</span></a>
                <div class="header-park-row-history">
                    <button type="button" class="park-switch-btn land" id="historyParkSwitchLand" data-park="land">🏰 ランド</button>
                    <button type="button" class="park-switch-btn sea" id="historyParkSwitchSea" data-park="sea">🌋 シー</button>
                </div>
                <div class="header-top-row2">
                    <button type="button" class="compare-header-btn" id="compareBtn" style="display:none;"><span class="header-btn-emoji">📅</span><span class="header-btn-text">比較</span></button>
                    <button type="button" class="compare-header-btn" id="weekendWeekdayBtn" style="display:none;"><span class="header-btn-emoji">📊</span><span class="header-btn-text">週末/平日</span></button>
                    <button type="button" class="compare-header-btn" id="eventManageBtn" style="display:none;"><span class="header-btn-emoji">🎪</span><span class="header-btn-text"><span class="header-btn-line">イベント</span><span class="header-btn-line">管理</span></span></button>
                    <div class="auth-status-chip" id="historyAuthStatusChipDesktop">
                        <span>未ログイン</span>
                    </div>
                    <button type="button" class="auth-small-btn auth-login-btn" id="historyGoogleLoginBtnDesktop">
                        <span>ログイン</span>
                    </button>
                    <button type="button" class="auth-small-btn" id="historyLogoutBtnDesktop" style="display:none;">
                        <span>ログアウト</span>
                    </button>
                </div>
            </div>
            <h1>📊 <span class="title-text">待ち時間履歴</span></h1>
            <p class="park-name" id="parkName">読み込み中...</p>
        </header>

        <div class="controls">
            <div class="day-view-event-wrap" id="dayViewEventWrap" style="display:none;"></div>
            <div class="controls-row">
                <button type="button" class="controls-back-btn" id="headerBackToListBtn" onclick="backToList()" style="display:none;">⬅️ 一覧</button>
                <div class="controls-center">
                    <div class="period-tabs">
                        <button class="period-tab active" data-period="day">日</button>
                        <button class="period-tab" data-period="week">週</button>
                        <button class="period-tab" data-period="month">月</button>
                        <button class="period-tab" data-period="year">年</button>
                    </div>
                    <select id="dateSelect">
                        <option value="">日付を選択...</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="content"></div>
    </div>

    <!-- 前回の来園日と比較モーダル（回り順プランナーと同様） -->
    <div class="compare-overlay" id="compareOverlay" style="display:none;" onclick="closeCompareOverlay(event)">
        <div class="compare-modal">
            <div class="compare-modal-header">
                <div class="compare-modal-title">📅 前回の来園日と比較</div>
                <button type="button" class="compare-modal-close" id="compareModalClose">✕</button>
            </div>
            <div class="compare-modal-body" id="compareModalBody"></div>
        </div>
    </div>

    <!-- 週末/平日比較モーダル -->
    <div class="compare-overlay" id="weekendWeekdayOverlay" style="display:none;" onclick="closeWeekendWeekdayOverlay(event)">
        <div class="compare-modal">
            <div class="compare-modal-header">
                <div class="compare-modal-title">📊 週末 vs 平日</div>
                <button type="button" class="compare-modal-close" id="weekendWeekdayModalClose">✕</button>
            </div>
            <div class="compare-modal-body" id="weekendWeekdayModalBody"></div>
        </div>
    </div>

    <!-- イベント管理モーダル -->
    <div class="compare-overlay" id="eventManageOverlay" style="display:none;" onclick="closeEventManageOverlay(event)">
        <div class="compare-modal event-manage-modal">
            <div class="compare-modal-header">
                <div class="compare-modal-title">🎪 イベント管理</div>
                <button type="button" class="compare-modal-close" id="eventManageModalClose">✕</button>
            </div>
            <div class="compare-modal-body" id="eventManageModalBody">
                <div class="event-manage-add">
                    <h4>イベントを追加</h4>
                    <div class="event-manage-form">
                        <input type="text" id="eventAddLabel" placeholder="イベント名（例: クリスマス）" class="ride-search-input">
                        <div class="event-manage-form-dates">
                            <input type="date" id="eventAddStart" class="ride-search-input">
                            <span class="event-manage-form-sep">〜</span>
                            <input type="date" id="eventAddEnd" class="ride-search-input">
                        </div>
                        <button type="button" class="btn" id="eventAddBtn">追加</button>
                    </div>
                </div>
                <div class="event-manage-list-wrap">
                    <h4>登録済みイベント</h4>
                    <ul class="event-manage-list" id="eventManageList"></ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // パーク・エリア・アトラクション情報は Supabase マスタ（master-from-supabase.js）から読み込み
        const USE_SUPABASE = typeof window !== 'undefined' && window.SUPABASE_URL && window.SUPABASE_ANON_KEY;

        let currentPark = null;
        let loadedData = null;
        let availableDates = [];
        let chart = null;
        let overviewChart = null;
        let selectedAreas = []; // 空配列 = すべて選択
        let currentPeriod = 'day'; // day, week, month, year
        let initialRideHandled = false; // URLパラメータのride処理済みフラグ
        let favoriteRideIds = new Set(); // お気に入りアトラクションID群（文字列）
        let showFavoritesOnly = false; // true のときお気に入りのみ表示
        let rideSearchQuery = ''; // 名前で検索の入力値（content内に配置するため保持）
        let compareRideIds = new Set(); // 詳細グラフの比較対象ID群（文字列）
        let currentDetailRideId = null; // 現在の詳細表示中アトラクションID
        let dateEventsList = []; // { id, event_label, start_date, end_date } の配列（1レコード1イベント、期間保持）
        let isHistoryEventAdmin = false; // Supabase 上の event_admins テーブルに登録された管理者かどうか

        const urlParams = new URLSearchParams(window.location.search);
        const parkParam = urlParams.get('park');
        const rideParam = urlParams.get('ride');

        /** マスタからアトラクション名を取得。無い場合は originalName を返す */
        function getRideName(rideId, originalName) {
            // park-data.js の統一構造 { area, name } から名前を取得
            const rideInfo = currentPark === 'land' ? TDL_RIDE_INFO[rideId] : TDS_RIDE_INFO[rideId];
            return rideInfo?.name || originalName;
        }

        /** マスタからアトラクションのエリアキーを取得。無い場合は 'other' */
        function getRideArea(rideId) {
            const rideInfo = currentPark === 'land' ? TDL_RIDE_INFO[rideId] : TDS_RIDE_INFO[rideId];
            return rideInfo?.area || 'other';
        }

        /** 現在パークのエリア一覧（TDL_AREAS / TDS_AREAS）を返す */
        function getAreas() {
            return currentPark === 'land' ? TDL_AREAS : TDS_AREAS;
        }

        function showLoadingOverlay() {
            const el = document.getElementById('loadingOverlay');
            if (el) el.classList.remove('hidden');
        }

        function hideLoadingOverlay() {
            const el = document.getElementById('loadingOverlay');
            if (el) el.classList.add('hidden');
        }

        // 初期化（マスタ取得後に currentPark を設定してから init 続行）
        document.addEventListener('DOMContentLoaded', () => {
            showLoadingOverlay();
            init().finally(() => {
                hideLoadingOverlay();
            });
        });

        /** ページ初期化：マスタ取得、パーク設定、日付取得・UIバインドを行う */
        async function init() {
            await loadMasterFromSupabase();
            if (parkParam && PARKS[parkParam]) {
                currentPark = parkParam;
            } else {
                currentPark = 'land';
            }

            // パーク切り替えボタン（履歴画面用）に現在のパーク状態を反映
            const historyParkSwitchLand = document.getElementById('historyParkSwitchLand');
            const historyParkSwitchSea = document.getElementById('historyParkSwitchSea');
            if (historyParkSwitchLand && historyParkSwitchSea) {
                const updateHistoryParkButtons = () => {
                    historyParkSwitchLand.classList.toggle('active', currentPark === 'land');
                    historyParkSwitchSea.classList.toggle('active', currentPark === 'sea');
                };
                historyParkSwitchLand.addEventListener('click', () => {
                    if (currentPark === 'land') return;
                    currentPark = 'land';
                    const search = new URLSearchParams(window.location.search);
                    search.set('park', 'land');
                    window.location.search = search.toString();
                });
                historyParkSwitchSea.addEventListener('click', () => {
                    if (currentPark === 'sea') return;
                    currentPark = 'sea';
                    const search = new URLSearchParams(window.location.search);
                    search.set('park', 'sea');
                    window.location.search = search.toString();
                });
                updateHistoryParkButtons();
            }

            const parkInfo = PARKS[currentPark];
            if (!parkInfo) {
                document.getElementById('content').innerHTML = '<div class="no-data"><h2>マスタを読み込めませんでした</h2><p>Supabase の設定と parks / areas / rides の登録を確認してください。</p></div>';
                return;
            }
            document.getElementById('parkName').textContent = `${parkInfo.icon} ${parkInfo.name}`;
            document.title = `${parkInfo.name} 待ち時間履歴`;
            
            document.querySelector('.back-btn').href = `index.html?park=${currentPark}`;

            const compareBtn = document.getElementById('compareBtn');
            if (compareBtn) {
                compareBtn.style.display = 'none';
                compareBtn.addEventListener('click', openCompareModal);
            }
            document.getElementById('compareModalClose').addEventListener('click', closeCompareModal);

            const weekendWeekdayBtn = document.getElementById('weekendWeekdayBtn');
            if (weekendWeekdayBtn) {
                weekendWeekdayBtn.style.display = 'none';
                weekendWeekdayBtn.addEventListener('click', openWeekendWeekdayModal);
            }
            const weekendWeekdayModalClose = document.getElementById('weekendWeekdayModalClose');
            if (weekendWeekdayModalClose) weekendWeekdayModalClose.addEventListener('click', closeWeekendWeekdayOverlay);

            const eventManageBtn = document.getElementById('eventManageBtn');
            if (eventManageBtn) {
                eventManageBtn.style.display = 'none'; // 初期状態では非表示（管理者判定後に更新）
                eventManageBtn.addEventListener('click', () => openEventManageOverlay());
            }
            document.getElementById('eventManageModalClose').addEventListener('click', closeEventManageOverlay);
            document.getElementById('eventManageOverlay').querySelector('.compare-modal').addEventListener('click', e => e.stopPropagation());
            document.getElementById('eventAddBtn').addEventListener('click', submitAddEvent);
            // お気に入りをローカルストレージから復元
            loadFavoriteRides();
            
            if (USE_SUPABASE) {
                await loadAvailableDatesFromSupabase();
            } else {
                const content = document.getElementById('content');
                content.innerHTML = `
                    <div class="no-data">
                        <h2>データを読み込むには Supabase の設定が必要です</h2>
                        <p>supabase-config.js に SUPABASE_URL と SUPABASE_ANON_KEY を設定してください。</p>
                    </div>
                `;
            }
        }

        /** Supabase REST API 用のリクエストヘッダーを返す（履歴データ取得など一般公開向け） */
        function getSupabaseHeaders() {
            return {
                'apikey': window.SUPABASE_ANON_KEY || '',
                'Authorization': 'Bearer ' + (window.SUPABASE_ANON_KEY || ''),
                'Accept': 'application/json'
            };
        }

        /** 現在ログイン中ユーザーがイベント管理者かどうかを Supabase で判定し、グローバル状態とボタン表示を更新する */
        async function refreshHistoryEventAdminState() {
            const client = getHistorySupabaseClient();
            if (!client) {
                isHistoryEventAdmin = false;
                updateEventManageButtonVisibility();
                return;
            }
            try {
                const { data: userData } = await client.auth.getUser();
                const user = userData && userData.user;
                if (!user) {
                    isHistoryEventAdmin = false;
                    updateEventManageButtonVisibility();
                    return;
                }
                const { data, error } = await client
                    .from('event_admins')
                    .select('id')
                    .eq('user_id', user.id)
                    .limit(1)
                    .maybeSingle();
                if (error) {
                    console.warn('event_admins check error', error);
                    isHistoryEventAdmin = false;
                } else {
                    isHistoryEventAdmin = !!data;
                }
            } catch (e) {
                console.warn('refreshHistoryEventAdminState error', e);
                isHistoryEventAdmin = false;
            } finally {
                updateEventManageButtonVisibility();
            }
        }

        /** イベント管理ボタンの表示・非表示を更新する */
        function updateEventManageButtonVisibility() {
            const eventManageBtn = document.getElementById('eventManageBtn');
            if (!eventManageBtn) return;
            if (!USE_SUPABASE) {
                eventManageBtn.style.display = 'none';
                return;
            }
            eventManageBtn.style.display = isHistoryEventAdmin ? '' : 'none';
        }

        /** 現在パークの date_events を取得し dateEventsList に格納する（閲覧用。管理者以外も取得可能な RLS を想定） */
        async function loadDateEvents() {
            if (!currentPark) { dateEventsList = []; return; }
            const client = getHistorySupabaseClient();
            if (!client) { dateEventsList = []; return; }
            try {
                const { data, error } = await client
                    .from('date_events')
                    .select('id,park_id,event_label,start_date,end_date')
                    .eq('park_id', currentPark)
                    .order('start_date', { ascending: false });
                if (error) {
                    console.warn('date_events fetch failed', error);
                    dateEventsList = [];
                    return;
                }
                dateEventsList = Array.isArray(data) ? data : [];
            } catch (e) {
                console.warn('date_events fetch failed', e);
                dateEventsList = [];
            }
        }

        /** 表示用の records */
        function getDisplayedRecords() {
            if (!loadedData || !loadedData.records) return [];
            return loadedData.records;
        }

        /** 日付 D が start_date <= D <= end_date に含まれるイベントのラベル配列を返す */
        function getEventsForDate(dateStr) {
            if (!dateStr || !dateEventsList.length) return [];
            return dateEventsList
                .filter(e => e.start_date <= dateStr && dateStr <= e.end_date)
                .map(e => e.event_label);
        }

        /** 日付 D に含まれるイベントレコード（id 付き）を返す（削除用） */
        function getEventRecordsForDate(dateStr) {
            if (!dateStr || !dateEventsList.length) return [];
            return dateEventsList.filter(e => e.start_date <= dateStr && dateStr <= e.end_date);
        }

        /** 日本時間の今日を YYYY-MM-DD で返す */
        function getTodayJstDateStr() {
            const f = new Intl.DateTimeFormat('en-CA', { timeZone: 'Asia/Tokyo', year: 'numeric', month: '2-digit', day: '2-digit' });
            return f.format(new Date());
        }

        /** イベント id の start_date〜end_date に含まれる日付をすべて列挙（YYYY-MM-DD） */
        function getDatesInEvent(eventId) {
            const ev = dateEventsList.find(e => e.id === eventId);
            if (!ev) return [];
            const out = [];
            const start = new Date(ev.start_date);
            const end = new Date(ev.end_date);
            for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                out.push(`${y}-${m}-${day}`);
            }
            return out;
        }

        /** イベント管理オーバーレイを開く。selectedDate を渡すと開始・終了日にセットする（イベント管理者のみ） */
        function openEventManageOverlay(selectedDate) {
            if (!isHistoryEventAdmin) {
                alert('この機能はイベント管理者のみ利用できます。');
                return;
            }
            const overlay = document.getElementById('eventManageOverlay');
            if (!overlay) return;
            if (selectedDate) {
                document.getElementById('eventAddStart').value = selectedDate;
                document.getElementById('eventAddEnd').value = selectedDate;
            } else {
                document.getElementById('eventAddStart').value = '';
                document.getElementById('eventAddEnd').value = '';
            }
            document.getElementById('eventAddLabel').value = '';
            renderEventManageList();
            overlay.style.display = 'flex';
        }

        /** イベント管理オーバーレイを閉じる（背景クリック時） */
        function closeEventManageOverlay(ev) {
            if (ev != null && ev.target !== ev.currentTarget) return;
            const overlay = document.getElementById('eventManageOverlay');
            if (overlay) overlay.style.display = 'none';
        }

        /** イベント管理画面の登録済みイベント一覧を描画する */
        function renderEventManageList() {
            const ul = document.getElementById('eventManageList');
            if (!ul) return;
            ul.innerHTML = dateEventsList.length === 0
                ? '<li class="event-manage-empty">登録済みイベントはありません。</li>'
                : dateEventsList.map(ev => `
                    <li data-id="${escapeHtml(ev.id)}">
                        <span class="event-item-label">${escapeHtml(ev.event_label)}</span>
                        <span class="event-item-dates">${escapeHtml(ev.start_date)} 〜 ${escapeHtml(ev.end_date)}</span>
                        <button type="button" class="event-item-delete" data-id="${escapeHtml(ev.id)}">削除</button>
                    </li>
                `).join('');
            ul.querySelectorAll('.event-item-delete').forEach(btn => {
                btn.addEventListener('click', () => deleteEventById(btn.dataset.id));
            });
        }

        /** イベント追加フォームの内容を Supabase に登録し、一覧を更新する（イベント管理者のみ） */
        async function submitAddEvent() {
            if (!isHistoryEventAdmin) {
                alert('この機能はイベント管理者のみ利用できます。');
                return;
            }
            const label = (document.getElementById('eventAddLabel').value || '').trim();
            const start = (document.getElementById('eventAddStart').value || '').trim();
            const end = (document.getElementById('eventAddEnd').value || '').trim();
            if (!label || !start || !end) {
                alert('イベント名・開始日・終了日を入力してください。');
                return;
            }
            if (start > end) {
                alert('開始日は終了日以前にしてください。');
                return;
            }
            const client = getHistorySupabaseClient();
            if (!client) {
                alert('Supabase クライアントが初期化されていません。supabase-config.js を確認してください。');
                return;
            }
            try {
                const { error } = await client
                    .from('date_events')
                    .insert({
                        park_id: currentPark,
                        event_label: label,
                        start_date: start,
                        end_date: end
                    });
                if (error) throw error;
                await loadDateEvents();
                renderEventManageList();
                document.getElementById('eventAddLabel').value = '';
                document.getElementById('eventAddStart').value = '';
                document.getElementById('eventAddEnd').value = '';
                refreshDateSelectOptionLabels();
                if (loadedData && currentPeriod === 'day') showAllRides();
            } catch (e) {
                console.error(e);
                alert('追加に失敗しました: ' + (e.message || e));
            }
        }

        /** 指定IDのイベントを Supabase から削除し、一覧を更新する（イベント管理者のみ） */
        async function deleteEventById(id) {
            if (!isHistoryEventAdmin) {
                alert('この機能はイベント管理者のみ利用できます。');
                return;
            }
            if (!id || !confirm('このイベントを削除しますか？')) return;
            const client = getHistorySupabaseClient();
            if (!client) {
                alert('Supabase クライアントが初期化されていません。supabase-config.js を確認してください。');
                return;
            }
            try {
                const { error } = await client
                    .from('date_events')
                    .delete()
                    .eq('id', id);
                if (error) throw error;
                await loadDateEvents();
                renderEventManageList();
                refreshDateSelectOptionLabels();
                if (loadedData && currentPeriod === 'day') showAllRides();
            } catch (e) {
                console.error(e);
                alert('削除に失敗しました: ' + (e.message || e));
            }
        }

        /** 日付選択のオプションラベルをイベント付きの表示に更新する */
        function refreshDateSelectOptionLabels() {
            if (currentPeriod !== 'day') return;
            const dateSelect = document.getElementById('dateSelect');
            if (!dateSelect) return;
            for (const opt of dateSelect.options) {
                if (opt.value) opt.textContent = formatDateForPeriod(opt.value, 'day');
            }
        }

        /** Supabase から取得可能な日付一覧を取得し、日付選択UIを構築する */
        async function loadAvailableDatesFromSupabase() {
            const parkInfo = PARKS[currentPark];
            const content = document.getElementById('content');
            const baseUrl = (window.SUPABASE_URL || '').replace(/\/$/, '');
            try {
                await loadDateEvents();
                const url = `${baseUrl}/rest/v1/wait_time_snapshots?park_id=eq.${encodeURIComponent(currentPark)}&select=date&order=timestamp.desc&limit=5000`;
                const response = await fetch(url, { method: 'GET', headers: getSupabaseHeaders(), cache: 'no-store' });
                if (!response.ok) throw new Error('Supabase からの取得に失敗しました');
                const rows = await response.json();
                const dateSet = new Set();
                (rows || []).forEach(r => { if (r.date) dateSet.add(r.date); });
                availableDates = [...dateSet].sort().reverse();

                if (availableDates.length === 0) {
                    content.innerHTML = `
                        <div class="no-data">
                            <h2>データがありません</h2>
                            <p>まだ履歴データが Supabase に登録されていません。</p>
                        </div>
                    `;
                    return;
                }
                document.getElementById('dateSelect').style.display = '';
                await updateDateSelectOptions();
            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = `
                    <div class="error">
                        <h3>エラーが発生しました</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        /** 指定パーク・日付の待ち時間スナップショットを Supabase から取得する */
        async function fetchSupabaseDataForDate(parkId, dateStr) {
            if (!dateStr || !parkId) return null;
            const baseUrl = (window.SUPABASE_URL || '').replace(/\/$/, '');
            const url = `${baseUrl}/rest/v1/wait_time_snapshots?park_id=eq.${encodeURIComponent(parkId)}&date=eq.${encodeURIComponent(dateStr)}&order=time.asc`;
            try {
                const response = await fetch(url, { method: 'GET', headers: getSupabaseHeaders(), cache: 'no-store' });
                if (!response.ok) return null;
                const rows = await response.json();
                if (!Array.isArray(rows) || rows.length === 0) return null;
                const parkInfo = PARKS[parkId];
                return {
                    date: dateStr,
                    records: rows.map(r => ({
                        date: r.date,
                        time: r.time,
                        timestamp: r.timestamp,
                        rides: r.rides || []
                    }))
                };
            } catch (e) {
                return null;
            }
        }

        /** 日付文字列を「○月○日(曜)」形式で表示用に整形する */
        function formatDate(dateStr) {
            const date = new Date(dateStr);
            const options = { month: 'long', day: 'numeric', weekday: 'short' };
            return date.toLocaleDateString('ja-JP', options);
        }

        /** 読み込み済みデータからアトラクション一覧（id, name）を取得（比較モード用） */
        function getRideListFromLoadedData() {
            const list = [];
            if (!loadedData || !loadedData.records.length) return list;
            const ridesMap = new Map();
            for (const record of loadedData.records) {
                for (const ride of record.rides) {
                    if (!ridesMap.has(ride.id)) {
                        ridesMap.set(ride.id, getRideName(ride.id, ride.name));
                    }
                }
            }
            return [...ridesMap.entries()].sort((a, b) => a[1].localeCompare(b[1], 'ja'));
        }

        /** 全アトラクション一覧・グラフ・ヒートマップ・カレンダーを描画する（フィルタ・検索適用） */
        function showAllRides() {
            const content = document.getElementById('content');
            const recordsToUse = getDisplayedRecords();
            if (!loadedData || recordsToUse.length === 0) return;

            const latestRecord = recordsToUse[recordsToUse.length - 1];
            const recordCount = recordsToUse.length;
            const firstTime = recordsToUse[0]?.time || '-';
            const lastTime = latestRecord?.time || '-';
            const areas = getAreas();

            // 各アトラクションの統計を計算
            const rideStats = new Map();
            
            for (const record of recordsToUse) {
                for (const ride of record.rides) {
                    if (!rideStats.has(ride.id)) {
                        rideStats.set(ride.id, {
                            id: ride.id,
                            name: getRideName(ride.id, ride.name),
                            area: getRideArea(ride.id),
                            waits: [],
                            timeData: [],
                            lastOpen: false,
                            lastWait: 0
                        });
                    }
                    const stat = rideStats.get(ride.id);
                    if (ride.is_open && ride.wait_time > 0) {
                        stat.waits.push(ride.wait_time);
                    }
                    stat.timeData.push({
                        date: record.date,
                        time: record.time,
                        wait: ride.is_open ? ride.wait_time : null
                    });
                    stat.lastOpen = ride.is_open;
                    stat.lastWait = ride.wait_time;
                }
            }

            // カード用データを生成（表示は5分刻み）
            let rideCards = [...rideStats.values()].map(stat => {
                const avgWait = stat.waits.length > 0 
                    ? roundTo5(stat.waits.reduce((a, b) => a + b, 0) / stat.waits.length) 
                    : 0;
                const maxWait = stat.waits.length > 0 ? Math.max(...stat.waits) : 0;
                const minWait = stat.waits.length > 0 ? Math.min(...stat.waits) : 0;
                
                return {
                    ...stat,
                    avgWait,
                    maxWait,
                    minWait
                };
            }).sort((a, b) => a.name.localeCompare(b.name, 'ja'));

            // エリアごとのカウント
            const areaCounts = {};
            Object.keys(areas).forEach(key => {
                areaCounts[key] = rideCards.filter(r => r.area === key).length;
            });

            // エリアでフィルター（空配列 = すべて選択）
            const isAllSelected = selectedAreas.length === 0;
            let filteredCards = isAllSelected 
                ? rideCards 
                : rideCards.filter(r => selectedAreas.includes(r.area));

            // お気に入りフィルタ適用（有効な場合）
            if (showFavoritesOnly && favoriteRideIds.size > 0) {
                filteredCards = filteredCards.filter(r => favoriteRideIds.has(String(r.id)));
            }

            // 名前の部分一致検索（content内のinputから読み、再描画用に保持）
            const searchEl = document.getElementById('rideSearchInput');
            if (searchEl) rideSearchQuery = searchEl.value;
            const searchQ = (rideSearchQuery || '').trim().toLowerCase();
            if (searchQ) {
                filteredCards = filteredCards.filter(r => (r.name || '').toLowerCase().includes(searchQ));
            }

            const openCount = filteredCards.filter(r => r.lastOpen).length;

            content.innerHTML = `
                <div class="search-fav-row">
                    <div class="favorites-toolbar">
                        <button class="fav-toggle-btn ${showFavoritesOnly ? 'active' : ''}" id="favToggleBtn">
                            ★ お気に入りだけ表示
                        </button>
                    </div>
                    <div class="ride-search-wrap">
                        <input type="text" class="ride-search-input" id="rideSearchInput" placeholder="名前で検索" autocomplete="off" value="${escapeHtml(rideSearchQuery || '')}">
                    </div>
                </div>
                <div class="area-filter-wrapper collapsed" id="areaFilterWrapper">
                    <button type="button" class="area-filter-toggle" id="areaFilterToggle" aria-expanded="false">
                        エリアで絞り込む <span class="area-filter-chevron" aria-hidden="true">▼</span>
                    </button>
                    <div class="area-tabs-body">
                        <div class="area-tabs" id="areaTabs">
                            <button class="area-tab ${isAllSelected ? 'active' : ''}" data-area="all">
                                <span class="area-icon">🎡</span>
                                <span>すべて</span>
                                <span class="area-count">${showFavoritesOnly ? filteredCards.length : rideCards.length}</span>
                            </button>
                            ${Object.entries(areas).map(([key, area]) => 
                                areaCounts[key] > 0 ? `
                                    <button class="area-tab area-${key} ${selectedAreas.includes(key) ? 'active' : ''}" data-area="${key}">
                                        <span class="area-icon">${area.icon}</span>
                                        <span>${area.name}</span>
                                        <span class="area-count">${areaCounts[key]}</span>
                                    </button>
                                ` : ''
                            ).join('')}
                        </div>
                    </div>
                </div>

                <div class="overview-chart-container">
                    <h2 class="chart-title">📈 待ち時間推移グラフ${!isAllSelected ? ` - ${selectedAreas.map(a => areas[a]?.icon).join(' ')}` : ''}</h2>
                    <div class="visit-summary" id="visitSummary"></div>
                    <canvas id="overviewChart"></canvas>
                    <div class="chart-legend" id="chartLegend"></div>
                </div>

                ${currentPeriod === 'week' ? renderWeeklyCalendar() : ''}
                ${currentPeriod === 'month' ? renderMonthlyCalendar() : ''}
                ${currentPeriod === 'year' ? renderYearlyCalendar() : ''}
                ${currentPeriod === 'day' ? renderHeatmapSection(filteredCards) : ''}
                ${renderDayTimeMatrix(filteredCards)}

                <div class="chart-container">
                    <h2 class="chart-title">全アトラクション一覧</h2>
                    <p style="text-align: center; color: #a0a0a0; margin-bottom: 20px;">カードをクリックするとグラフを表示</p>
                    ${renderAreaSections(filteredCards, areas)}
                </div>
            `;

            // 期間選択の上にイベント表示（日＝選択日、週/月/年＝今日のイベント）
            const dayViewEventWrap = document.getElementById('dayViewEventWrap');
            if (dayViewEventWrap) {
                if (loadedData) {
                    dayViewEventWrap.innerHTML = renderEventLineForPeriod();
                    dayViewEventWrap.style.display = 'block';
                } else {
                    dayViewEventWrap.innerHTML = '';
                    dayViewEventWrap.style.display = 'none';
                }
            }

            // 全体グラフを描画
            renderOverviewChart(filteredCards);

            // スマホ表示時、ヒートマップの横スクロールを現在時刻の位置に
            setTimeout(() => scrollHeatmapToCurrentTime(content), 0);

            // 同じ時間帯の過去○週間スパークラインを非同期で取得・描画
            loadAndDrawListSparklines();

            // お気に入りトグルボタンのイベントリスナー（ログイン必須）
            const favToggleBtn = document.getElementById('favToggleBtn');
            if (favToggleBtn) {
                favToggleBtn.addEventListener('click', async () => {
                    const client = typeof getHistorySupabaseClient === 'function' ? getHistorySupabaseClient() : null;
                    if (!client) {
                        showFavLoginModal('Supabase の設定が行われていないため、お気に入り機能は利用できません。<br>管理者にお問い合わせください。');
                        return;
                    }
                    try {
                        const { data } = await client.auth.getUser();
                        const user = data && data.user;
                        if (!user) {
                            showFavLoginModal();
                            return;
                        }
                    } catch (e) {
                        console.warn('Failed to check auth state for favorites toggle (history)', e);
                        showFavLoginModal('現在、お気に入り機能を利用できません。<br>時間をおいて再度お試しください。');
                        return;
                    }

                    showFavoritesOnly = !showFavoritesOnly;
                    showAllRides();
                });
            }

            // 名前で検索のイベントリスナー
            const rideSearchInput = document.getElementById('rideSearchInput');
            if (rideSearchInput) {
                rideSearchInput.addEventListener('input', () => {
                    rideSearchQuery = rideSearchInput.value;
                    if (currentDetailRideId === null && loadedData) showAllRides();
                });
            }

            // スマホ用: エリア絞り込みトグル
            const areaFilterToggle = document.getElementById('areaFilterToggle');
            const areaFilterWrapper = document.getElementById('areaFilterWrapper');
            if (areaFilterToggle && areaFilterWrapper) {
                areaFilterToggle.addEventListener('click', function () {
                    areaFilterWrapper.classList.toggle('collapsed');
                    areaFilterToggle.setAttribute('aria-expanded', areaFilterWrapper.classList.contains('collapsed') ? 'false' : 'true');
                });
            }

            // 前回の来園日と比較・週末/平日（日ビューのみ）：ヘッダーボタンの表示切替
            const compareBtn = document.getElementById('compareBtn');
            if (compareBtn) compareBtn.style.display = currentPeriod === 'day' ? '' : 'none';
            const weekendWeekdayBtn = document.getElementById('weekendWeekdayBtn');
            if (weekendWeekdayBtn) weekendWeekdayBtn.style.display = currentPeriod === 'day' ? '' : 'none';

            // エリアタブのイベントリスナー（複数選択対応）
            content.querySelectorAll('.area-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const area = tab.dataset.area;
                    
                    if (area === 'all') {
                        // 「すべて」をクリック → 全選択（配列を空に）
                        selectedAreas = [];
                    } else {
                        // 個別エリアをクリック → トグル
                        if (selectedAreas.includes(area)) {
                            // 選択解除
                            selectedAreas = selectedAreas.filter(a => a !== area);
                            // 全部未選択になったら自動的にすべて選択
                            // （selectedAreas が空 = すべて選択なので何もしなくてOK）
                        } else {
                            // 選択追加
                            selectedAreas.push(area);
                        }
                    }
                    showAllRides();
                });
            });

            // カードクリックイベント
            content.querySelectorAll('.ride-card').forEach(card => {
                card.addEventListener('click', () => {
                    const rideId = parseInt(card.dataset.rideId);
                    showRideDetail(rideId);
                });
            });

            // お気に入りボタンのイベントリスナー（カードクリックとは独立させる）
            content.querySelectorAll('.ride-card-fav-btn').forEach(btn => {
                btn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    const rideId = btn.dataset.rideId;
                    if (!rideId) return;
                    toggleFavoriteRide(rideId);
                    // 画面を再描画して状態を反映
                    showAllRides();
                });
            });
        }

        /** 全体の待ち時間推移グラフ（日/週/月/年に対応）を Chart.js で描画する */
        function renderOverviewChart(rideCards) {
            const ctx = document.getElementById('overviewChart');
            if (!ctx) return;

            if (overviewChart) {
                overviewChart.destroy();
            }

            // 拡張カラーパレット
            const colors = [
                '#4ecdc4', '#ff6b6b', '#f9ca24', '#45b7d1', '#e84393',
                '#00b894', '#fdcb6e', '#6c5ce7', '#fd79a8', '#00cec9',
                '#e17055', '#74b9ff', '#a29bfe', '#55efc4', '#ffeaa7',
                '#dfe6e9', '#81ecec', '#fab1a0', '#ff7675', '#636e72',
                '#b2bec3', '#2d3436', '#d63031', '#e84393', '#0984e3',
                '#6c5ce7', '#00b894', '#fdcb6e', '#e17055', '#74b9ff',
                '#a29bfe', '#55efc4', '#ffeaa7', '#dfe6e9', '#81ecec',
                '#fab1a0', '#ff7675', '#636e72', '#b2bec3', '#2d3436'
            ];

            // 全アトラクション（平均待ち時間が長い順にソート）
            const allRides = [...rideCards]
                .filter(r => r.avgWait > 0)
                .sort((a, b) => b.avgWait - a.avgWait);

            let labels, datasets, xAxisTitle;

            if (currentPeriod === 'day') {
                // 日単位: 9:00〜21:00 を30分刻みで表示
                labels = [];
                for (let h = 9; h <= 21; h++) {
                    labels.push(`${h.toString().padStart(2, '0')}:00`);
                    if (h !== 21) {
                        labels.push(`${h.toString().padStart(2, '0')}:30`);
                    }
                }
                xAxisTitle = '時刻';

                datasets = allRides.map((ride, index) => {
                    // 9:00〜21:00 を30分刻み
                    const slotData = new Array(labels.length).fill(null);
                    for (const td of ride.timeData) {
                        if (td.wait !== null) {
                            const [hours, minutes] = td.time.split(':').map(Number);
                            if (hours < 9 || hours > 21) continue;
                            // 9:00 を 0、9:30 を 1 ... 21:00 にマッピング（表示は5分刻み）
                            const baseIndex = (hours - 9) * 2;
                            const index30 = minutes >= 30 ? baseIndex + 1 : baseIndex;
                            if (index30 >= 0 && index30 < slotData.length) {
                                slotData[index30] = roundTo5(td.wait);
                            }
                        }
                    }
                    return {
                        label: ride.name,
                        data: slotData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        fill: false, tension: 0.4, spanGaps: true, pointRadius: 6, pointHoverRadius: 10, borderWidth: 4, hidden: false,
                        rideId: ride.id
                    };
                });
            } else if (currentPeriod === 'week') {
                // 週単位: 選択した週（必ず日曜始まり）の7日分を X 軸に表示（例: 2/5(木)）
                const weekStartStr = loadedData?.selectedValue; // その週の日曜日（YYYY-MM-DD）
                const weekDates = [];
                if (weekStartStr) {
                    const weekStart = parseDateStringToLocalDate(weekStartStr);
                    for (let i = 0; i < 7; i++) {
                        const d = new Date(weekStart);
                        d.setDate(weekStart.getDate() + i);
                        const y = d.getFullYear();
                        const m = String(d.getMonth() + 1).padStart(2, '0');
                        const day = String(d.getDate()).padStart(2, '0');
                        weekDates.push(`${y}-${m}-${day}`);
                    }
                }
                labels = weekDates.map(d => formatWeekDateLabel(d));
                xAxisTitle = '日付';

                datasets = allRides.map((ride, index) => {
                    const dayData = new Array(weekDates.length).fill(null);
                    const dayWaits = weekDates.map(() => []);
                    
                    for (const td of ride.timeData) {
                        if (td.wait !== null && td.date) {
                            const pos = weekDates.indexOf(td.date);
                            if (pos !== -1) {
                                dayWaits[pos].push(td.wait);
                            }
                        }
                    }
                    
                    for (let i = 0; i < weekDates.length; i++) {
                        if (dayWaits[i].length > 0) {
                            dayData[i] = roundTo5(dayWaits[i].reduce((a, b) => a + b, 0) / dayWaits[i].length);
                        }
                    }
                    
                    return {
                        label: ride.name,
                        data: dayData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        fill: false, tension: 0.4, spanGaps: true, pointRadius: 6, pointHoverRadius: 10, borderWidth: 4, hidden: false,
                        rideId: ride.id
                    };
                });
            } else if (currentPeriod === 'month') {
                // 月単位: 日付軸（その月の全日付を表示）
                const selectedMonth = loadedData.selectedValue || '';
                const [year, month] = selectedMonth.split('-');
                const daysInMonth = new Date(parseInt(year), parseInt(month), 0).getDate();
                
                // その月の全日付を生成
                const allDatesInMonth = [];
                for (let d = 1; d <= daysInMonth; d++) {
                    allDatesInMonth.push(`${year}-${month}-${d.toString().padStart(2, '0')}`);
                }
                
                labels = allDatesInMonth.map(d => parseInt(d.split('-')[2]) + '日');
                xAxisTitle = '日付';

                datasets = allRides.map((ride, index) => {
                    const dateMap = {};
                    for (const td of ride.timeData) {
                        if (td.wait !== null && td.date) {
                            if (!dateMap[td.date]) dateMap[td.date] = [];
                            dateMap[td.date].push(td.wait);
                        }
                    }
                    
                    const dayData = allDatesInMonth.map(date => {
                        if (dateMap[date] && dateMap[date].length > 0) {
                            return roundTo5(dateMap[date].reduce((a, b) => a + b, 0) / dateMap[date].length);
                        }
                        return null;
                    });
                    
                    return {
                        label: ride.name,
                        data: dayData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        fill: false, tension: 0.4, spanGaps: true, pointRadius: 6, pointHoverRadius: 10, borderWidth: 4, hidden: false,
                        rideId: ride.id
                    };
                });
            } else {
                // 年単位: 月軸
                labels = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
                xAxisTitle = '月';

                datasets = allRides.map((ride, index) => {
                    const monthWaits = Array(12).fill(null).map(() => []);
                    
                    for (const td of ride.timeData) {
                        if (td.wait !== null && td.date) {
                            const month = parseInt(td.date.split('-')[1]) - 1;
                            monthWaits[month].push(td.wait);
                        }
                    }
                    
                    const monthData = monthWaits.map(waits => {
                        if (waits.length > 0) {
                            return roundTo5(waits.reduce((a, b) => a + b, 0) / waits.length);
                        }
                        return null;
                    });
                    
                    return {
                        label: ride.name,
                        data: monthData,
                        borderColor: colors[index % colors.length],
                        backgroundColor: colors[index % colors.length] + '20',
                        fill: false, tension: 0.4, spanGaps: true, pointRadius: 6, pointHoverRadius: 10, borderWidth: 4, hidden: false,
                        rideId: ride.id
                    };
                });
            }

            // X軸のtick設定を期間に応じて設定
            const xTicksConfig = {
                color: '#a0a0a0',
                maxRotation: currentPeriod === 'month' ? 45 : 0,
                font: { size: 14, weight: 'bold' }
            };
            if (currentPeriod === 'day') {
                // 30分刻みデータだが、ラベルは1時間ごとに表示
                xTicksConfig.callback = function(val, index) { 
                    return index % 2 === 0 ? this.getLabelForValue(val) : ''; 
                };
            } else if (currentPeriod === 'month' && labels.length > 15) {
                xTicksConfig.callback = function(val, index) { 
                    return index % 5 === 0 ? this.getLabelForValue(val) : ''; 
                };
            }

            overviewChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    interaction: {
                        mode: 'nearest',
                        intersect: true
                    },
                    onClick: (event) => {
                        if (!overviewChart) return;

                        // Chart.js のイベントからネイティブイベントを取得
                        const nativeEvent = event && event.native ? event.native : event;

                        // クリック位置に最も近いポイント群を取得（Y方向を含む距離で判定）
                        const nearestPoints = overviewChart.getElementsAtEventForMode(
                            event,
                            'nearest',
                            { intersect: true },
                            false
                        );
                        if (!nearestPoints.length) return;

                        const labels = overviewChart.data.labels;
                        const datasets = overviewChart.data.datasets;

                        // 「一番近いポイント」の datasetIndex / index をベースに候補を作成
                        // （Xインデックスで横一列を拾うのではなく、nearest が返したポイントだけを対象にする）
                        const candidates = [];
                        const seen = new Set();

                        nearestPoints.forEach(pt => {
                            const dsIndex = pt.datasetIndex;
                            const idx = pt.index;
                            const ds = datasets[dsIndex];
                            if (!ds) return;

                            const meta = overviewChart.getDatasetMeta(dsIndex);
                            const value = ds.data[idx];
                            const rideId = ds.rideId;
                            if (value == null || meta.hidden) return;
                            if (typeof rideId !== 'number' || isNaN(rideId)) return;

                            const key = `${rideId}-${idx}`;
                            if (seen.has(key)) return;
                            seen.add(key);

                            candidates.push({
                                rideId,
                                name: ds.label,
                                wait: value,
                                timeLabel: labels[idx]
                            });
                        });

                        if (!candidates.length || !nativeEvent) return;

                        if (candidates.length === 1) {
                            const target = candidates[0];
                            showRideDetail(target.rideId);
                            return;
                        }

                        // 複数重なっている場合はポップアップで選択
                        showPointPopup(candidates, nativeEvent);
                    },
                    plugins: {
                        legend: {
                            display: false // カスタムレジェンドを使用
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.raw === null) return null;
                                    return `${context.dataset.label}: ${context.raw}分`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: xTicksConfig,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: xAxisTitle,
                                color: '#a0a0a0',
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#a0a0a0', font: { size: 14, weight: 'bold' } },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: '待ち時間（分）',
                                color: '#a0a0a0',
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                }
            });

            // カスタムレジェンドを生成
            const legendContainer = document.getElementById('chartLegend');
            if (legendContainer) {
                legendContainer.innerHTML = datasets.map((ds, i) => `
                    <div class="legend-item ${ds.hidden ? 'hidden' : ''}" data-index="${i}">
                        <span class="legend-color" style="background: ${ds.borderColor}"></span>
                        <span>${escapeHtml(ds.label)}</span>
                    </div>
                `).join('');

                // レジェンドクリックで表示/非表示切り替え
                legendContainer.querySelectorAll('.legend-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const index = parseInt(item.dataset.index);
                        const meta = overviewChart.getDatasetMeta(index);
                        meta.hidden = !meta.hidden;
                        item.classList.toggle('hidden', meta.hidden);
                        overviewChart.update();
                    });
                });
            }

            // おすすめ来園時間サマリーを描画（週・月・年のとき）
            const summaryContainer = document.getElementById('visitSummary');
            if (summaryContainer) {
                const summary = computeVisitSummary();
                if (!summary) {
                    summaryContainer.innerHTML = '';
                    summaryContainer.style.display = 'none';
                } else {
                    summaryContainer.style.display = 'block';
                    summaryContainer.innerHTML = `
                        <div class="visit-summary-title">${summary.title}</div>
                        <div class="visit-summary-items">
                            ${summary.items.map(item => `
                                <div class="visit-summary-item">
                                    <span class="visit-summary-rank">${item.rank}位</span>
                                    <span>${item.label}</span>
                                    <span>（平均 ${item.avgMinutes}分）</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                }
            }
        }

        /** 指定日のイベント行HTML。日ビュー時は選択日、それ以外は今日のイベントを表示 */
        function renderEventLineForPeriod() {
            const dateStr = currentPeriod === 'day' && loadedData && loadedData.selectedValue
                ? loadedData.selectedValue
                : getTodayJstDateStr();
            const dateLabel = currentPeriod === 'day' && loadedData && loadedData.selectedValue
                ? (() => {
                    const d = new Date(dateStr);
                    return d.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' });
                })()
                : (() => {
                    const d = new Date(dateStr + 'T12:00:00');
                    return '今日のイベント (' + d.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' }) + ')';
                })();
            const eventRecords = getEventRecordsForDate(dateStr);
            const cardsHtml = eventRecords.length > 0
                ? eventRecords.map(e => `<span class="today-events-item"><span class="today-events-item-label">${escapeHtml(e.event_label)}</span><span class="today-events-item-period">${escapeHtml(e.start_date)} 〜 ${escapeHtml(e.end_date)}</span></span>`).join('')
                : '<span class="today-events-item"><span class="today-events-item-label">イベント無し</span></span>';
            return `
                <div class="day-view-event-line">
                    <div class="today-events-title">${escapeHtml(dateLabel)}</div>
                    <div class="today-events-list">${cardsHtml}</div>
                </div>
            `;
        }

        /** 日単位の待ち時間ヒートマップ（9〜21時・30分刻み）を描画する */
        function renderHeatmapSection(rideCards) {
            if (!rideCards || rideCards.length === 0 || !loadedData || getDisplayedRecords().length === 0) {
                return '';
            }

            // 9:00〜21:00 を30分刻みでスロット化
            const slots = [];
            for (let h = 9; h <= 21; h++) {
                const hh = h.toString().padStart(2, '0');
                slots.push(`${hh}:00`);
                if (h !== 21) slots.push(`${hh}:30`);
            }

            const rowsHtml = rideCards.map(ride => {
                const sums = new Array(slots.length).fill(0);
                const counts = new Array(slots.length).fill(0);

                for (const td of ride.timeData) {
                    if (td.wait == null || !td.time) continue;
                    const [hours, minutes] = td.time.split(':').map(Number);
                    if (hours < 9 || hours > 21) continue;
                    const base = (hours - 9) * 2;
                    const idx = minutes >= 30 ? base + 1 : base;
                    if (idx < 0 || idx >= slots.length) continue;
                    sums[idx] += td.wait;
                    counts[idx] += 1;
                }

                const cells = sums.map((sum, i) => {
                    if (!counts[i]) {
                        return '<td class="heatmap-cell heat-none"></td>';
                    }
                    const avg = roundTo5(sum / counts[i]);
                    const waitClass = getWaitClass(avg) || '';
                    return `<td class="heatmap-cell ${waitClass || 'heat-none'}">${avg}</td>`;
                }).join('');

                return `
                    <tr>
                        <td class="heatmap-ride-name">${escapeHtml(ride.name)}</td>
                        ${cells}
                    </tr>
                `;
            }).join('');

            const headerCells = slots.map(t => `<th class="heatmap-header">${t}</th>`).join('');

            return `
                <div class="heatmap-container">
                    <h3 class="heatmap-title">⏱ 混雑ヒートマップ（9:00〜21:00）</h3>
                    <div class="heatmap-note">色が濃いほど平均待ち時間が長い時間帯です。</div>
                    <div class="heatmap-table-wrapper">
                        <table class="heatmap-table">
                            <thead>
                                <tr>
                                    <th class="heatmap-header">アトラクション</th>
                                    ${headerCells}
                                </tr>
                            </thead>
                            <tbody>
                                ${rowsHtml}
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        /** 月単位のカレンダー（日付ごとの混み具合）を描画する */
        function renderMonthlyCalendar() {
            if (!loadedData || loadedData.period !== 'month') return '';

            const value = loadedData.selectedValue; // "YYYY-MM"
            if (!value) return '';

            const [yearStr, monthStr] = value.split('-');
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);
            if (!year || !month) return '';

            // 日ごとの平均待ち時間を集計
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const rec of getDisplayedRecords()) {
                if (!rec.date) continue;
                if (!dailyStats.has(rec.date)) {
                    dailyStats.set(rec.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(rec.date);
                for (const ride of rec.rides) {
                    if (ride.is_open && ride.wait_time > 0) {
                        stat.sum += ride.wait_time;
                        stat.count += 1;
                    }
                }
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            // カレンダーの枠組み（その月の1日〜末日）
            const firstDay = new Date(year, month - 1, 1);
            const lastDay = new Date(year, month, 0);
            const firstWeekday = firstDay.getDay(); // 0=日
            const totalDays = lastDay.getDate();

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];

            const cells = [];

            // 曜日ヘッダ
            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            // 空白セル（1日が始まる前まで）
            for (let i = 0; i < firstWeekday; i++) {
                cells.push('<div class="calendar-cell-empty"></div>');
            }

            // 各日付セル
            for (let day = 1; day <= totalDays; day++) {
                const d = String(day).padStart(2, '0');
                const monthPadded = String(month).padStart(2, '0');
                const dateStr = `${year}-${monthPadded}-${d}`;

                const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                const hasData = avg != null;
                const weekday = new Date(year, month - 1, day).getDay();

                const disp = hasData ? roundTo5(avg) : null;
                const waitClass = hasData ? getWaitClass(disp) : '';
                const disabledClass = loadedData.dateRange.includes(dateStr) && hasData ? '' : 'disabled';
                const label = hasData ? `${disp}分` : '-';

                const cellHtml = `
                    <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                        <div class="calendar-day-header">
                            <span class="calendar-day-date">${day}</span>
                            <span class="calendar-day-weekday">${weekdays[weekday]}</span>
                        </div>
                        <div class="calendar-day-value">${label}</div>
                    </div>
                `;
                cells.push(cellHtml);
            }

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="calendar-grid">
                        ${headerRow}
                        ${cells.join('')}
                    </div>
                </div>
            `;
        }

        /** 年単位のカレンダー（月ごとの混み具合）を描画する */
        function renderYearlyCalendar() {
            if (!loadedData || loadedData.period !== 'year') return '';

            const value = loadedData.selectedValue; // "YYYY"
            if (!value) return '';

            const year = parseInt(value, 10);
            if (!year) return '';

            // 日ごとの平均待ち時間を集計
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const rec of getDisplayedRecords()) {
                if (!rec.date) continue;
                if (!dailyStats.has(rec.date)) {
                    dailyStats.set(rec.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(rec.date);
                for (const ride of rec.rides) {
                    if (ride.is_open && ride.wait_time > 0) {
                        stat.sum += ride.wait_time;
                        stat.count += 1;
                    }
                }
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
            const monthNames = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            let calendarsHtml = '';

            // 12ヶ月分のカレンダーを生成
            for (let month = 1; month <= 12; month++) {
                const firstDay = new Date(year, month - 1, 1);
                const lastDay = new Date(year, month, 0);
                const firstWeekday = firstDay.getDay();
                const totalDays = lastDay.getDate();

                const cells = [];

                // 空白セル（1日が始まる前まで）
                for (let i = 0; i < firstWeekday; i++) {
                    cells.push('<div class="calendar-cell-empty"></div>');
                }

                // 各日付セル
                for (let day = 1; day <= totalDays; day++) {
                    const d = String(day).padStart(2, '0');
                    const monthPadded = String(month).padStart(2, '0');
                    const dateStr = `${year}-${monthPadded}-${d}`;

                    const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                    const hasData = avg != null;
                    const weekday = new Date(year, month - 1, day).getDay();
                    const disp = hasData ? roundTo5(avg) : null;
                    const waitClass = hasData ? getWaitClass(disp) : '';
                    const disabledClass = loadedData.dateRange.includes(dateStr) && hasData ? '' : 'disabled';
                    const label = hasData ? `${disp}分` : '-';

                    const cellHtml = `
                        <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                            <div class="calendar-day-header">
                                <span class="calendar-day-date">${day}</span>
                                <span class="calendar-day-weekday">${weekdays[weekday]}</span>
                            </div>
                            <div class="calendar-day-value">${label}</div>
                        </div>
                    `;
                    cells.push(cellHtml);
                }

                calendarsHtml += `
                    <div class="year-calendar-month">
                        <h4 class="year-calendar-month-title">${year}年${monthNames[month - 1]}</h4>
                        <div class="calendar-grid year-calendar-grid">
                            ${headerRow}
                            ${cells.join('')}
                        </div>
                    </div>
                `;
            }

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー（${year}年）</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="year-calendars-wrapper">
                        ${calendarsHtml}
                    </div>
                </div>
            `;
        }

        /** 週単位のカレンダー（日曜始まり7日分の混み具合）を描画する */
        function renderWeeklyCalendar() {
            if (!loadedData || loadedData.period !== 'week') return '';

            const weekStartStr = loadedData.selectedValue; // その週の日曜日（YYYY-MM-DD）
            if (!weekStartStr) return '';

            const weekStart = parseDateStringToLocalDate(weekStartStr);
            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(weekStart);
                d.setDate(weekStart.getDate() + i);
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                weekDates.push(`${y}-${m}-${day}`);
            }

            // 日ごとの平均待ち時間を集計
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const rec of getDisplayedRecords()) {
                if (!rec.date) continue;
                if (!dailyStats.has(rec.date)) {
                    dailyStats.set(rec.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(rec.date);
                for (const ride of rec.rides) {
                    if (ride.is_open && ride.wait_time > 0) {
                        stat.sum += ride.wait_time;
                        stat.count += 1;
                    }
                }
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];

            const cells = weekDates.map((dateStr, i) => {
                const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                const hasData = avg != null;
                const disp = hasData ? roundTo5(avg) : null;
                const waitClass = hasData ? getWaitClass(disp) : '';
                const disabledClass = hasData ? '' : 'disabled';
                const label = hasData ? `${disp}分` : '-';
                const day = parseInt(dateStr.split('-')[2], 10);
                const hasEvent = getEventsForDate(dateStr).length > 0;
                const eventBadge = hasEvent ? '<span class="calendar-day-event-badge" title="イベント日">🎪</span>' : '';

                return `
                    <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                        <div class="calendar-day-header">
                            <span class="calendar-day-date">${day}</span>
                            <span class="calendar-day-weekday">${weekdays[i]}</span>
                            ${eventBadge}
                        </div>
                        <div class="calendar-day-value">${label}</div>
                    </div>
                `;
            });

            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="calendar-grid">
                        ${headerRow}
                        ${cells.join('')}
                    </div>
                </div>
            `;
        }

        /** 単一アトラクションの週カレンダー（曜日別の平均待ち時間）を描画する */
        function renderSingleRideWeeklyCalendar(rideId, rideData) {
            if (!loadedData || loadedData.period !== 'week' || !rideData || rideData.length === 0) return '';

            const weekStartStr = loadedData.selectedValue; // その週の日曜日（YYYY-MM-DD）
            if (!weekStartStr) return '';

            const weekStart = parseDateStringToLocalDate(weekStartStr);
            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const d = new Date(weekStart);
                d.setDate(weekStart.getDate() + i);
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                weekDates.push(`${y}-${m}-${day}`);
            }

            // 日ごとの平均待ち時間を集計（このアトラクションのみ）
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const d of rideData) {
                if (!d.date) continue;
                if (!d.is_open || d.wait_time == null || d.wait_time <= 0) continue;
                if (!dailyStats.has(d.date)) {
                    dailyStats.set(d.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(d.date);
                stat.sum += d.wait_time;
                stat.count += 1;
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];

            const cells = weekDates.map((dateStr, i) => {
                const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                const hasData = avg != null;
                const disp = hasData ? roundTo5(avg) : null;
                const waitClass = hasData ? getWaitClass(disp) : '';
                const disabledClass = hasData ? '' : 'disabled';
                const label = hasData ? `${disp}分` : '-';
                const day = parseInt(dateStr.split('-')[2], 10);

                return `
                    <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                        <div class="calendar-day-header">
                            <span class="calendar-day-date">${day}</span>
                            <span class="calendar-day-weekday">${weekdays[i]}</span>
                        </div>
                        <div class="calendar-day-value">${label}</div>
                    </div>
                `;
            });

            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="calendar-grid">
                        ${headerRow}
                        ${cells.join('')}
                    </div>
                </div>
            `;
        }

        // ── 曜日×時間帯マトリクス ──

        /** 曜日×時間帯の集計行列を構築する（dataIterator は { dow, hourIdx, wait } のイテレータ） */
        function buildDayTimeMatrix(dataIterator) {
            // 7曜日 x 13時間帯 (9〜21時) の集計用マトリクス
            const matrix = Array.from({ length: 7 }, () =>
                Array.from({ length: 13 }, () => ({ sum: 0, count: 0 }))
            );

            for (const item of dataIterator) {
                const cell = matrix[item.dow][item.hourIdx];
                cell.sum += item.wait;
                cell.count += 1;
            }

            return matrix;
        }

        /** 曜日×時間帯の行列を表形式HTMLで描画する。options.onlyDow で特定曜日のみ表示可能 */
        function renderDayTimeMatrixHtml(matrix, title, options) {
            const onlyDow = options && options.onlyDow !== undefined ? options.onlyDow : null;
            const dayLabels = ['日', '月', '火', '水', '木', '金', '土'];
            const hourSlots = [];
            for (let h = 9; h <= 21; h++) hourSlots.push(h);

            // 曜日ごとの最小値セルを探す
            const bestPerDay = []; // { hourIdx, avg } or null
            for (let dow = 0; dow < 7; dow++) {
                let bestHi = -1, bestAvg = Infinity;
                for (let hi = 0; hi < hourSlots.length; hi++) {
                    const c = matrix[dow][hi];
                    if (c.count > 0) {
                        const avg = c.sum / c.count;
                        if (avg < bestAvg) {
                            bestAvg = avg;
                            bestHi = hi;
                        }
                    }
                }
                bestPerDay.push(bestHi >= 0 ? { hourIdx: bestHi, avg: bestAvg } : null);
            }

            const headerCells = hourSlots.map(h => `<th class="heatmap-header">${h}時</th>`).join('');

            const rowsToRender = onlyDow !== null ? [onlyDow] : [0, 1, 2, 3, 4, 5, 6];
            const rowsHtml = rowsToRender.map(dow => {
                const label = dayLabels[dow];
                const best = bestPerDay[dow];
                const cells = hourSlots.map((h, hi) => {
                    const c = matrix[dow][hi];
                    if (!c.count) {
                        return '<td class="heatmap-cell heat-none">-</td>';
                    }
                    const avg = roundTo5(c.sum / c.count);
                    const waitClass = getWaitClass(avg) || '';
                    const bestClass = (best && hi === best.hourIdx) ? ' matrix-best-cell' : '';
                    return `<td class="heatmap-cell ${waitClass || 'heat-none'}${bestClass}">${avg}</td>`;
                }).join('');

                return `<tr><td class="matrix-day-label">${label}</td>${cells}</tr>`;
            }).join('');

            const tipHtml = '';
            const noteText = onlyDow !== null
                ? 'その日の時間帯別平均待ち時間です。黄色枠が狙い目です。'
                : '蓄積データから曜日×時間帯の平均待ち時間を算出しています。黄色枠が各曜日の狙い目です。';

            return `
                <div class="heatmap-container">
                    <h3 class="heatmap-title">${title}</h3>
                    <div class="heatmap-note">${noteText}</div>
                    <div class="heatmap-table-wrapper">
                        <table class="heatmap-table">
                            <thead>
                                <tr>
                                    <th class="heatmap-header">曜日</th>
                                    ${headerCells}
                                </tr>
                            </thead>
                            <tbody>${rowsHtml}</tbody>
                        </table>
                    </div>
                    ${tipHtml}
                </div>
            `;
        }

        /** 全アトラクションの曜日×時間帯マトリクスを描画する */
        function renderDayTimeMatrix(filteredCards) {
            if (!filteredCards || filteredCards.length === 0) return '';

            // 全アトラクション合算のデータイテレータを作成
            const items = [];
            for (const ride of filteredCards) {
                for (const td of ride.timeData) {
                    if (td.wait == null || !td.time || !td.date) continue;
                    const hour = parseInt(td.time.split(':')[0], 10);
                    if (hour < 9 || hour > 21) continue;
                    const [y, m, d] = td.date.split('-').map(Number);
                    const dow = new Date(y, m - 1, d).getDay();
                    items.push({ dow, hourIdx: hour - 9, wait: td.wait });
                }
            }

            if (items.length === 0) return '';

            const matrix = buildDayTimeMatrix(items);
            const title = currentPeriod === 'day' ? '📅 今日のおすすめ時間帯' : '📅 曜日別おすすめ時間帯';
            let onlyDow = null;
            if (currentPeriod === 'day' && loadedData && (loadedData.dateRange?.length > 0 || loadedData.selectedValue)) {
                const dateStr = loadedData.dateRange?.[0] || loadedData.selectedValue;
                const [y, m, d] = dateStr.split('-').map(Number);
                onlyDow = new Date(y, m - 1, d).getDay();
            }
            return renderDayTimeMatrixHtml(matrix, title, { onlyDow });
        }

        /** 単一アトラクションの曜日×時間帯マトリクスを描画する */
        function renderSingleRideDayTimeMatrix(rideId, rideName, rideData) {
            if (!rideData || rideData.length === 0) return '';

            const items = [];
            for (const d of rideData) {
                if (!d.is_open || d.wait_time == null || d.wait_time <= 0 || !d.time || !d.date) continue;
                const hour = parseInt(d.time.split(':')[0], 10);
                if (hour < 9 || hour > 21) continue;
                const [y, m, day] = d.date.split('-').map(Number);
                const dow = new Date(y, m - 1, day).getDay();
                items.push({ dow, hourIdx: hour - 9, wait: d.wait_time });
            }

            if (items.length === 0) return '';

            const matrix = buildDayTimeMatrix(items);
            const title = currentPeriod === 'day' ? '📅 今日のおすすめ時間帯' : '📅 曜日別おすすめ時間帯';
            let onlyDow = null;
            if (currentPeriod === 'day' && rideData.length > 0 && rideData[0].date) {
                const [y, m, d] = rideData[0].date.split('-').map(Number);
                onlyDow = new Date(y, m - 1, d).getDay();
            }
            return renderDayTimeMatrixHtml(matrix, title, { onlyDow });
        }

        /** 単一アトラクションの日単位ヒートマップ（9〜21時）を描画する */
        function renderSingleRideHeatmap(rideId, rideName, rideData) {
            if (!rideData || rideData.length === 0 || currentPeriod !== 'day') {
                return '';
            }

            // 9:00〜21:00 を30分刻みでスロット化
            const slots = [];
            for (let h = 9; h <= 21; h++) {
                const hh = h.toString().padStart(2, '0');
                slots.push(`${hh}:00`);
                if (h !== 21) slots.push(`${hh}:30`);
            }

            const sums = new Array(slots.length).fill(0);
            const counts = new Array(slots.length).fill(0);

            for (const d of rideData) {
                if (!d.is_open || d.wait_time == null || !d.time) continue;
                const [hours, minutes] = d.time.split(':').map(Number);
                if (hours < 9 || hours > 21) continue;
                const base = (hours - 9) * 2;
                const idx = minutes >= 30 ? base + 1 : base;
                if (idx < 0 || idx >= slots.length) continue;
                sums[idx] += d.wait_time;
                counts[idx] += 1;
            }

            const cells = sums.map((sum, i) => {
                if (!counts[i]) {
                    return '<td class="heatmap-cell heat-none">-</td>';
                }
                const avg = roundTo5(sum / counts[i]);
                const waitClass = getWaitClass(avg) || '';
                return `<td class="heatmap-cell ${waitClass || 'heat-none'}">${avg}</td>`;
            }).join('');

            const headerCells = slots.map(t => `<th class="heatmap-header">${t}</th>`).join('');

            return `
                <div class="heatmap-container">
                    <h3 class="heatmap-title">⏱ 時間帯別 混雑ヒートマップ（9:00〜21:00）</h3>
                    <div class="heatmap-note">色が濃いほど待ち時間が長い時間帯です。</div>
                    <div class="heatmap-table-wrapper">
                        <table class="heatmap-table">
                            <thead>
                                <tr>
                                    <th class="heatmap-header">アトラクション</th>
                                    ${headerCells}
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td class="heatmap-ride-name">${escapeHtml(rideName)}</td>
                                    ${cells}
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
        }

        /** 単一アトラクションの月カレンダー（日付別の平均待ち時間）を描画する */
        function renderSingleRideMonthlyCalendar(rideId, rideData) {
            if (!loadedData || loadedData.period !== 'month' || !rideData || rideData.length === 0) return '';

            const value = loadedData.selectedValue; // "YYYY-MM"
            if (!value) return '';

            const [yearStr, monthStr] = value.split('-');
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);
            if (!year || !month) return '';

            // 日ごとの平均待ち時間を集計（このアトラクションのみ）
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const d of rideData) {
                if (!d.date) continue;
                if (!d.is_open || d.wait_time == null || d.wait_time <= 0) continue;
                if (!dailyStats.has(d.date)) {
                    dailyStats.set(d.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(d.date);
                stat.sum += d.wait_time;
                stat.count += 1;
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            // カレンダーの枠組み（その月の1日〜末日）
            const firstDay = new Date(year, month - 1, 1);
            const lastDay = new Date(year, month, 0);
            const firstWeekday = firstDay.getDay(); // 0=日
            const totalDays = lastDay.getDate();

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];

            const cells = [];

            // 曜日ヘッダ
            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            // 空白セル（1日が始まる前まで）
            for (let i = 0; i < firstWeekday; i++) {
                cells.push('<div></div>');
            }

            // 各日付セル
            for (let day = 1; day <= totalDays; day++) {
                const d = String(day).padStart(2, '0');
                const monthPadded = String(month).padStart(2, '0');
                const dateStr = `${year}-${monthPadded}-${d}`;

                const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                const hasData = avg != null;
                const weekday = new Date(year, month - 1, day).getDay();
                const disp = hasData ? roundTo5(avg) : null;
                const waitClass = hasData ? getWaitClass(disp) : '';
                const disabledClass = hasData ? '' : 'disabled';
                const label = hasData ? `${disp}分` : '-';

                const cellHtml = `
                    <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                        <div class="calendar-day-header">
                            <span class="calendar-day-date">${day}</span>
                            <span class="calendar-day-weekday">${weekdays[weekday]}</span>
                        </div>
                        <div class="calendar-day-value">${label}</div>
                    </div>
                `;
                cells.push(cellHtml);
            }

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="calendar-grid">
                        ${headerRow}
                        ${cells.join('')}
                    </div>
                </div>
            `;
        }

        /** 単一アトラクションの年カレンダー（月別の平均待ち時間）を描画する */
        function renderSingleRideYearlyCalendar(rideId, rideData) {
            if (!loadedData || loadedData.period !== 'year' || !rideData || rideData.length === 0) return '';

            const value = loadedData.selectedValue; // "YYYY"
            if (!value) return '';

            const year = parseInt(value, 10);
            if (!year) return '';

            // 日ごとの平均待ち時間を集計（このアトラクションのみ）
            const dailyStats = new Map(); // date(YYYY-MM-DD) -> { sum, count }
            for (const d of rideData) {
                if (!d.date) continue;
                if (!d.is_open || d.wait_time == null || d.wait_time <= 0) continue;
                if (!dailyStats.has(d.date)) {
                    dailyStats.set(d.date, { sum: 0, count: 0 });
                }
                const stat = dailyStats.get(d.date);
                stat.sum += d.wait_time;
                stat.count += 1;
            }

            const dateToAvg = new Map(); // date -> avgMinutes
            dailyStats.forEach((stat, date) => {
                if (stat.count > 0) {
                    dateToAvg.set(date, stat.sum / stat.count);
                }
            });

            const weekdays = ['日', '月', '火', '水', '木', '金', '土'];
            const monthNames = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
            const headerRow = weekdays.map(w => `<div class="calendar-weekday">${w}</div>`).join('');

            let calendarsHtml = '';

            // 12ヶ月分のカレンダーを生成
            for (let month = 1; month <= 12; month++) {
                const firstDay = new Date(year, month - 1, 1);
                const lastDay = new Date(year, month, 0);
                const firstWeekday = firstDay.getDay();
                const totalDays = lastDay.getDate();

                const cells = [];

                // 空白セル（1日が始まる前まで）
                for (let i = 0; i < firstWeekday; i++) {
                    cells.push('<div></div>');
                }

                // 各日付セル
                for (let day = 1; day <= totalDays; day++) {
                    const d = String(day).padStart(2, '0');
                    const monthPadded = String(month).padStart(2, '0');
                    const dateStr = `${year}-${monthPadded}-${d}`;

                    const avg = dateToAvg.has(dateStr) ? dateToAvg.get(dateStr) : null;
                    const hasData = avg != null;
                    const weekday = new Date(year, month - 1, day).getDay();
                    const disp = hasData ? roundTo5(avg) : null;
                    const waitClass = hasData ? getWaitClass(disp) : '';
                    const disabledClass = hasData ? '' : 'disabled';
                    const label = hasData ? `${disp}分` : '-';

                    const cellHtml = `
                        <div class="calendar-day ${waitClass || ''} ${disabledClass}" ${hasData ? `onclick="jumpToDay('${dateStr}')"` : ''}>
                            <div class="calendar-day-header">
                                <span class="calendar-day-date">${day}</span>
                                <span class="calendar-day-weekday">${weekdays[weekday]}</span>
                            </div>
                            <div class="calendar-day-value">${label}</div>
                        </div>
                    `;
                    cells.push(cellHtml);
                }

                calendarsHtml += `
                    <div class="year-calendar-month">
                        <h4 class="year-calendar-month-title">${year}年${monthNames[month - 1]}</h4>
                        <div class="calendar-grid">
                            ${headerRow}
                            ${cells.join('')}
                        </div>
                    </div>
                `;
            }

            return `
                <div class="calendar-container">
                    <h3 class="calendar-title">📅 混雑カレンダー（${year}年）</h3>
                    <div class="calendar-note">その日の平均待ち時間で色分けしています。クリックすると日別詳細に移動します。</div>
                    <div class="year-calendars-wrapper">
                        ${calendarsHtml}
                    </div>
                </div>
            `;
        }

        /** エリア別にアトラクションカード群を描画する */
        function renderAreaSections(rideCards, areas) {
            if (!rideCards || rideCards.length === 0) {
                return '<div class="no-rides">該当するアトラクションがありません</div>';
            }
            const sorted = [...rideCards].sort((a, b) => {
                if (!a.waits.length) return 1;
                if (!b.waits.length) return -1;
                return b.avgWait - a.avgWait;
            });
            return `
                <div class="rides-grid">
                    ${sorted.map(ride => renderRideCard(ride)).join('')}
                </div>
            `;
        }

        /** 1件のアトラクションカード（履歴一覧用）のHTMLを生成する */
        function renderRideCard(ride) {
            const cardClass = ride.waits.length === 0 ? 'closed' : '';
            const avgClass = getWaitClass(ride.avgWait);
            const maxClass = getWaitClass(ride.maxWait);
            const minClass = getWaitClass(ride.minWait);
            const waitCardClass = ride.waits.length > 0 ? (avgClass || '') : '';
            const isFavorite = favoriteRideIds && favoriteRideIds.has(String(ride.id));
            
            return `
                <div class="ride-card ${cardClass} ${waitCardClass}" data-ride-id="${ride.id}">
                    <div class="ride-card-header">
                        <span class="ride-card-name">${escapeHtml(ride.name)}</span>
                        <button class="ride-card-fav-btn ${isFavorite ? 'active' : ''}" data-ride-id="${ride.id}" title="${isFavorite ? 'お気に入りから外す' : 'お気に入りに追加'}">
                            ★
                        </button>
                    </div>
                    ${ride.waits.length > 0 ? `
                        <div class="ride-card-stats">
                            <div class="ride-card-stat">
                                <span class="ride-card-stat-label">平均</span>
                                <span class="ride-card-stat-value ${avgClass}">${ride.avgWait}<span class="unit">分</span></span>
                            </div>
                            <div class="ride-card-stat">
                                <span class="ride-card-stat-label">最大</span>
                                <span class="ride-card-stat-value ${maxClass}">${ride.maxWait}<span class="unit">分</span></span>
                            </div>
                            <div class="ride-card-stat">
                                <span class="ride-card-stat-label">最小</span>
                                <span class="ride-card-stat-value ${minClass}">${ride.minWait}<span class="unit">分</span></span>
                            </div>
                        </div>
                    ` : `
                        <div class="ride-card-no-data">データなし</div>
                    `}
                    <div class="sparkline-wrap" data-ride-id="${ride.id}" aria-hidden="true">
                        <div class="sparkline-title">同じ時間帯の過去${SPARKLINE_WEEKS}週間</div>
                        <div class="sparkline-canvas-wrap"></div>
                    </div>
                </div>
            `;
        }

        /** この日のデータから「よく空く時間帯」上位3つを計算し、表示用HTMLを返す */
        function getBestTimeSlotsHtml(rideData) {
            const byHour = new Map(); // hour -> { sum, count }
            for (const d of rideData) {
                if (!d.is_open || d.wait_time == null || d.wait_time <= 0) continue;
                const timeStr = d.time || '';
                const hour = parseInt(String(timeStr).split(':')[0], 10);
                if (Number.isNaN(hour) || hour < 0 || hour > 23) continue;
                const cur = byHour.get(hour) || { sum: 0, count: 0 };
                cur.sum += d.wait_time;
                cur.count += 1;
                byHour.set(hour, cur);
            }
            const entries = [];
            byHour.forEach((v, hour) => {
                if (v.count >= 1) entries.push({ hour, avg: v.sum / v.count });
            });
            entries.sort((a, b) => a.avg - b.avg);
            const top3 = entries.slice(0, 3).map(e => e.hour).sort((a, b) => a - b);
            if (top3.length === 0) return '';
            return `
                <div class="data-info-best-times">
                    <div class="data-info-best-times-title">よく空く時間帯（この日のデータ）</div>
                    <div class="data-info-best-times-value">${top3.map(h => h + '時').join('・')}頃</div>
                </div>
            `;
        }

        /**
         * 相関分析結果のHTMLを生成する
         * @param {Array<{rideId: string, rideName: string, correlation: number}>} correlations - 相関結果の配列
         * @param {string} primaryRideName - 基準となるアトラクション名
         * @returns {string} HTML文字列（相関がない場合は空文字）
         */
        function renderCorrelationHtml(correlations, primaryRideName) {
            if (!correlations || correlations.length === 0) {
                return '';
            }

            const itemsHtml = correlations.map(corr => {
                // 相関係数の強さに応じてクラスを付与
                const strengthClass = corr.correlation <= -0.5 ? 'strong' : 'moderate';
                return `
                    <div class="correlation-item ${strengthClass}">
                        <span class="correlation-ride-name">${escapeHtml(corr.rideName)}</span>
                    </div>
                `;
            }).join('');

            return `
                <div class="correlation-section">
                    <div class="correlation-section-title">📊 相関分析（過去1か月の同じ曜日）</div>
                    <div class="correlation-section-description">${escapeHtml(primaryRideName)}が混むと、以下のアトラクションが空きやすい傾向があります：</div>
                    <div class="correlation-items">
                        ${itemsHtml}
                    </div>
                </div>
            `;
        }

        function showRideDetail(rideId) {
            // スクロールを一番上に戻す
            window.scrollTo(0, 0);
            
            const content = document.getElementById('content');
            currentDetailRideId = rideId;
            
            const collected = collectRideData(rideId);
            const rideName = collected.rideName;
            const rideData = collected.data || [];

            const waits = rideData.filter(d => d.is_open && d.wait_time > 0).map(d => d.wait_time);
            const avgWait = waits.length > 0 ? roundTo5(waits.reduce((a, b) => a + b, 0) / waits.length) : 0;
            const maxWait = waits.length > 0 ? Math.max(...waits) : 0;
            const minWait = waits.length > 0 ? Math.min(...waits) : 0;

            const bestTimeSlotsHtml = getBestTimeSlotsHtml(rideData);

            // 期間に応じたヒートマップ・カレンダーのHTML
            const heatmapHtml = currentPeriod === 'day' ? renderSingleRideHeatmap(rideId, rideName, rideData) : '';
            const dayTimeMatrixHtml = renderSingleRideDayTimeMatrix(rideId, rideName, rideData);
            const weekCalendarHtml = currentPeriod === 'week' ? renderSingleRideWeeklyCalendar(rideId, rideData) : '';
            const monthCalendarHtml = currentPeriod === 'month' ? renderSingleRideMonthlyCalendar(rideId, rideData) : '';
            const yearCalendarHtml = currentPeriod === 'year' ? renderSingleRideYearlyCalendar(rideId, rideData) : '';

            document.getElementById('headerBackToListBtn').style.display = 'inline-flex';
            content.innerHTML = `
                <div class="data-info">
                    <h3>📊 ${rideName}</h3>
                    <div class="data-info-grid">
                        <div class="data-info-item">
                            <div class="data-info-value">${avgWait}分</div>
                            <div class="data-info-label">平均待ち時間</div>
                        </div>
                        <div class="data-info-item">
                            <div class="data-info-value">${minWait}分</div>
                            <div class="data-info-label">最短</div>
                        </div>
                        <div class="data-info-item">
                            <div class="data-info-value">${maxWait}分</div>
                            <div class="data-info-label">最長</div>
                        </div>
                        <div class="data-info-item">
                            <div class="data-info-value">${rideData.length}</div>
                            <div class="data-info-label">記録数</div>
                        </div>
                    </div>
                    ${bestTimeSlotsHtml}
                    <div id="correlationSection"></div>
                </div>
                <div class="sparkline-detail" id="detailSparklineSection" style="display:none;">
                    <div class="sparkline-title">📈 同じ時間帯の過去${SPARKLINE_WEEKS}週間の推移</div>
                    <div class="sparkline-canvas-wrap" id="detailSparklineCanvas"></div>
                </div>
                <div class="compare-toolbar">
                    <div class="compare-toolbar-header">
                        <div class="compare-toolbar-title">📌 比較モード</div>
                        <div style="font-size: 0.75rem; color: #a0a0a0;">他のアトラクションの平均を重ねて表示できます</div>
                    </div>
                    <div>
                        <select id="compareSelect" class="compare-select">
                            <option value="">アトラクションを選択して追加...</option>
                        </select>
                        <div class="compare-chips" id="compareChips"></div>
                    </div>
                </div>
                <div class="chart-container">
                    <h2 class="chart-title">待ち時間推移グラフ</h2>
                    <canvas id="waitTimeChart"></canvas>
                </div>
                ${weekCalendarHtml}
                ${monthCalendarHtml}
                ${yearCalendarHtml}
                ${heatmapHtml}
                ${dayTimeMatrixHtml}
                <div class="chart-container">
                    <h2 class="chart-title">詳細データ</h2>
                    <div class="table-container">
                        <table id="dataTable">
                            <thead>
                                <tr>
                                    <th>時刻</th>
                                    <th>状態</th>
                                    <th>待ち時間</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            `;

            setupCompareControls(rideId, rideName, rideData);
            renderChart(rideName, rideData, rideId);
            renderTable(rideData);
            // スマホ表示時、ヒートマップの横スクロールを現在時刻の位置に
            setTimeout(() => scrollHeatmapToCurrentTime(content), 0);
            // 同じ時間帯の過去○週間スパークラインを非同期で描画
            loadDetailSparkline(rideId);
            // 相関分析を非同期で計算・表示
            computeRideCorrelations(rideId, currentPark).then(correlations => {
                const section = document.getElementById('correlationSection');
                if (section) {
                    const html = renderCorrelationHtml(correlations, rideName);
                    section.innerHTML = html;
                }
            }).catch(err => {
                console.warn('Failed to compute correlations', err);
            });
        }

        /** 読み込み済みデータから指定アトラクションの時系列データを集約して返す */
        function collectRideData(rideId) {
            const rideData = [];
            let rideName = '';

            if (!loadedData || !loadedData.records) {
                return { rideName: '', data: [] };
            }

            for (const record of loadedData.records) {
                const ride = record.rides.find(r => r.id === rideId);
                if (ride) {
                    rideName = getRideName(ride.id, ride.name);
                    rideData.push({
                        date: record.date,
                        time: record.time,
                        datetime: `${record.date} ${record.time}`,
                        is_open: ride.is_open,
                        wait_time: ride.wait_time
                    });
                }
            }

            return { rideName, data: rideData };
        }

        /**
         * 選択したアトラクションと他の全アトラクションとの待ち時間の相関（負の相関）を計算する
         * 過去約1か月（5週間）の同じ曜日のスナップショットデータからピアソン相関係数を計算
         * @param {string|number} primaryRideId - 基準となるアトラクションID
         * @param {string} parkId - パークID ('land' or 'sea')
         * @returns {Promise<Array<{rideId: string, rideName: string, correlation: number}>>} 負の相関が強いアトラクションの配列（相関係数の昇順）
         */
        async function computeRideCorrelations(primaryRideId, parkId) {
            if (!USE_SUPABASE || !primaryRideId || !parkId) {
                return [];
            }

            const primaryKey = String(primaryRideId);
            const todayStr = getTodayJstDateStr();
            const [tYear, tMonth, tDay] = todayStr.split('-').map(n => parseInt(n, 10));
            const baseDate = new Date(tYear, tMonth - 1, tDay);
            const MAX_WEEKS = 5; // 過去約1か月の同じ曜日を対象

            // 各アトラクションごとの待ち時間ペアを記録: rideId -> [primaryWait, otherWait][]
            const pairsByRide = new Map();

            // 過去5週間の同じ曜日のスナップショットを取得
            for (let weekOffset = 1; weekOffset <= MAX_WEEKS; weekOffset++) {
                const target = new Date(baseDate.getTime() - weekOffset * 7 * 86400000);
                const y = target.getFullYear();
                const m = String(target.getMonth() + 1).padStart(2, '0');
                const d = String(target.getDate()).padStart(2, '0');
                const dateStr = `${y}-${m}-${d}`;

                try {
                    const data = await fetchSupabaseDataForDate(parkId, dateStr);
                    if (!data || !Array.isArray(data.records)) continue;

                    for (const record of data.records) {
                        const ridesAtTime = record.rides || [];
                        const primaryRide = ridesAtTime.find(r => String(r.id) === primaryKey);
                        
                        // 基準アトラクションが運営中かつ待ち時間 > 0 の場合のみ処理
                        if (!primaryRide || !primaryRide.is_open || !primaryRide.wait_time || primaryRide.wait_time <= 0) {
                            continue;
                        }

                        const primaryWait = primaryRide.wait_time;

                        // 他の各アトラクションとのペアを記録
                        for (const otherRide of ridesAtTime) {
                            const otherKey = String(otherRide.id);
                            if (otherKey === primaryKey) continue; // 自分自身は除外
                            if (!otherRide.is_open || !otherRide.wait_time || otherRide.wait_time <= 0) continue;

                            if (!pairsByRide.has(otherKey)) {
                                pairsByRide.set(otherKey, []);
                            }
                            pairsByRide.get(otherKey).push([primaryWait, otherRide.wait_time]);
                        }
                    }
                } catch (e) {
                    console.warn('Failed to fetch correlation data for', dateStr, e);
                    continue;
                }
            }

            // ピアソン相関係数を計算
            const correlations = [];
            const MIN_PAIRS = 10; // データが少ない場合は除外

            pairsByRide.forEach((pairs, rideId) => {
                if (pairs.length < MIN_PAIRS) return;

                const n = pairs.length;
                const primaryValues = pairs.map(p => p[0]);
                const otherValues = pairs.map(p => p[1]);

                // 平均値を計算
                const primaryMean = primaryValues.reduce((a, b) => a + b, 0) / n;
                const otherMean = otherValues.reduce((a, b) => a + b, 0) / n;

                // 偏差の積和と分散を計算
                let covariance = 0;
                let primaryVariance = 0;
                let otherVariance = 0;

                for (let i = 0; i < n; i++) {
                    const primaryDev = primaryValues[i] - primaryMean;
                    const otherDev = otherValues[i] - otherMean;
                    covariance += primaryDev * otherDev;
                    primaryVariance += primaryDev * primaryDev;
                    otherVariance += otherDev * otherDev;
                }

                // ピアソン相関係数を計算
                const denominator = Math.sqrt(primaryVariance * otherVariance);
                if (denominator === 0) return;

                const correlation = covariance / denominator;

                // 負の相関が強い（-0.3以下）場合のみ追加
                if (correlation < -0.3) {
                    const rideName = getRideName(rideId, '');
                    correlations.push({
                        rideId,
                        rideName,
                        correlation
                    });
                }
            });

            // 相関係数の昇順（負の相関が強い順）でソート
            correlations.sort((a, b) => a.correlation - b.correlation);

            return correlations;
        }

        /** 詳細画面の比較用UI（他アトラクション選択・日付比較など）を設定する */
        function setupCompareControls(primaryRideId, primaryRideName, primaryRideData) {
            const select = document.getElementById('compareSelect');
            const chipsContainer = document.getElementById('compareChips');
            if (!select || !chipsContainer) return;

            const rideList = getRideListFromLoadedData();
            const labelMap = new Map(rideList.map(([id, name]) => [String(id), name]));

            // 比較対象候補をセレクトにセット（現在のプライマリと既に追加済みは除外）
            select.innerHTML = '<option value="">アトラクションを選択して追加...</option>';
            rideList.forEach(([id, name]) => {
                if (String(id) === String(primaryRideId)) return;
                if (compareRideIds.has(String(id))) return;
                const option = document.createElement('option');
                option.value = id;
                option.textContent = name;
                select.appendChild(option);
            });

            // 現在の比較対象チップを描画（存在しないIDは除外）
            const validCompareIds = [];
            compareRideIds.forEach(id => {
                if (labelMap.has(id) && id !== String(primaryRideId)) {
                    validCompareIds.push(id);
                }
            });
            // 不正なIDはセットから取り除く
            compareRideIds = new Set(validCompareIds);

            chipsContainer.innerHTML = validCompareIds.map(id => `
                <div class="compare-chip" data-ride-id="${id}">
                    <span>${escapeHtml(labelMap.get(id) || id)}</span>
                    <button type="button" data-remove-id="${id}">×</button>
                </div>
            `).join('');

            // セレクト変更で比較対象追加
            select.onchange = () => {
                const value = select.value;
                if (!value) return;
                compareRideIds.add(String(value));
                select.value = '';
                setupCompareControls(primaryRideId, primaryRideName, primaryRideData);
                renderChart(primaryRideName, primaryRideData, primaryRideId);
            };

            // チップの×クリックで削除
            chipsContainer.querySelectorAll('button[data-remove-id]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = btn.getAttribute('data-remove-id');
                    if (!id) return;
                    compareRideIds.delete(String(id));
                    setupCompareControls(primaryRideId, primaryRideName, primaryRideData);
                    renderChart(primaryRideName, primaryRideData, primaryRideId);
                });
            });
        }

        /** 詳細画面の待ち時間グラフ（日/週/月/年・比較線対応）を Chart.js で描画する */
        function renderChart(rideName, rideData, primaryRideId) {
            const ctx = document.getElementById('waitTimeChart');
            if (!ctx) return;

            if (chart) {
                chart.destroy();
            }

            let labels = [];
            let xAxisTitle = '';

            // ラベルと、与えられた rideData から集計配列を作るヘルパーを期間ごとに用意
            let buildSeries;

            if (currentPeriod === 'day') {
                // 日単位: 9:00〜21:00 を30分刻みで表示
                for (let h = 9; h <= 21; h++) {
                    labels.push(`${h.toString().padStart(2, '0')}:00`);
                    if (h !== 21) {
                        labels.push(`${h.toString().padStart(2, '0')}:30`);
                    }
                }
                xAxisTitle = '時刻';
                buildSeries = (series) => {
                    const data = new Array(labels.length).fill(null);
                    for (const d of series) {
                        if (d.is_open && d.wait_time !== null) {
                            const [hours, minutes] = d.time.split(':').map(Number);
                            if (hours < 9 || hours > 21) continue;
                            const baseIndex = (hours - 9) * 2;
                            const index30 = minutes >= 30 ? baseIndex + 1 : baseIndex;
                            if (index30 >= 0 && index30 < data.length) {
                                data[index30] = d.wait_time;
                            }
                        }
                    }
                    return data;
                };
            } else if (currentPeriod === 'week') {
                // 週単位: 選択した週（日曜始まり）の7日分を X 軸に表示（例: 2/5(木)）
                const weekStartStr = loadedData?.selectedValue;
                const weekDates = [];
                if (weekStartStr) {
                    const weekStart = parseDateStringToLocalDate(weekStartStr);
                    for (let i = 0; i < 7; i++) {
                        const d = new Date(weekStart);
                        d.setDate(weekStart.getDate() + i);
                        const y = d.getFullYear();
                        const m = String(d.getMonth() + 1).padStart(2, '0');
                        const day = String(d.getDate()).padStart(2, '0');
                        weekDates.push(`${y}-${m}-${day}`);
                    }
                }
                labels = weekDates.map(d => formatWeekDateLabel(d));
                xAxisTitle = '日付';
                buildSeries = (series) => {
                    const buckets = weekDates.map(() => []);
                    for (const d of series) {
                        if (d.is_open && d.wait_time !== null && d.date) {
                            const pos = weekDates.indexOf(d.date);
                            if (pos !== -1) {
                                buckets[pos].push(d.wait_time);
                            }
                        }
                    }
                    return buckets.map(waits =>
                        waits.length > 0 ? Math.round(waits.reduce((a, b) => a + b, 0) / waits.length) : null
                    );
                };
            } else if (currentPeriod === 'month') {
                // 月単位: 日ごとの平均（その月の全日付を表示）
                const selectedMonth = loadedData.selectedValue || '';
                const [year, month] = selectedMonth.split('-');
                const daysInMonth = new Date(parseInt(year), parseInt(month), 0).getDate();
                labels = Array.from({ length: daysInMonth }, (_, i) => `${i + 1}日`);
                xAxisTitle = '日';
                buildSeries = (series) => {
                    const buckets = Array(daysInMonth).fill(null).map(() => []);
                    for (const d of series) {
                        if (d.is_open && d.wait_time !== null && d.date) {
                            const dayNum = parseInt(d.date.split('-')[2], 10);
                            if (dayNum >= 1 && dayNum <= daysInMonth) {
                                buckets[dayNum - 1].push(d.wait_time);
                            }
                        }
                    }
                    return buckets.map(waits =>
                        waits.length > 0 ? Math.round(waits.reduce((a, b) => a + b, 0) / waits.length) : null
                    );
                };
            } else if (currentPeriod === 'year') {
                // 年単位: 月ごとの平均
                labels = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'];
                xAxisTitle = '月';
                buildSeries = (series) => {
                    const buckets = Array(12).fill(null).map(() => []);
                    for (const d of series) {
                        if (d.is_open && d.wait_time !== null && d.date) {
                            const monthNum = parseInt(d.date.split('-')[1], 10) - 1;
                            if (monthNum >= 0 && monthNum < 12) {
                                buckets[monthNum].push(d.wait_time);
                            }
                        }
                    }
                    return buckets.map(waits =>
                        waits.length > 0 ? Math.round(waits.reduce((a, b) => a + b, 0) / waits.length) : null
                    );
                };
            }

            const primarySeries = buildSeries ? buildSeries(rideData) : [];

            // X軸のtick設定を期間に応じて設定
            const xTicksConfig2 = {
                color: '#a0a0a0',
                maxRotation: currentPeriod === 'month' ? 45 : 0,
                font: { size: 14, weight: 'bold' }
            };
            if (currentPeriod === 'day') {
                // 30分刻みデータだが、ラベルは1時間ごとに表示
                xTicksConfig2.callback = function(val, index) { 
                    return index % 2 === 0 ? this.getLabelForValue(val) : ''; 
                };
            } else if (currentPeriod === 'month' && labels.length > 15) {
                xTicksConfig2.callback = function(val, index) { 
                    return index % 5 === 0 ? this.getLabelForValue(val) : ''; 
                };
            }

            // データセット（プライマリ＋比較対象）を構築
            const datasets = [{
                label: rideName,
                data: primarySeries,
                borderColor: '#4ecdc4',
                backgroundColor: 'rgba(78, 205, 196, 0.2)',
                fill: true,
                tension: 0.4,
                spanGaps: true,
                pointRadius: 6,
                pointHoverRadius: 10,
                borderWidth: 4
            }];

            // 比較対象用カラーパレット
            const compareColors = [
                '#ff6b6b',
                '#f9ca24',
                '#45b7d1',
                '#e84393',
                '#00b894',
                '#fdcb6e',
                '#6c5ce7',
                '#fd79a8'
            ];

            if (buildSeries && compareRideIds.size > 0 && loadedData && loadedData.records) {
                const compareIds = Array.from(compareRideIds);
                compareIds.forEach((id, idx) => {
                    const { rideName: cmpName, data: cmpRaw } = collectRideData(parseInt(id, 10));
                    if (!cmpRaw || !cmpRaw.length) return;
                    const cmpSeries = buildSeries(cmpRaw);
                    datasets.push({
                        label: cmpName || `ID ${id}`,
                        data: cmpSeries,
                        borderColor: compareColors[idx % compareColors.length],
                        backgroundColor: 'transparent',
                        fill: false,
                        tension: 0.4,
                        spanGaps: true,
                        pointRadius: 4,
                        pointHoverRadius: 8,
                        borderWidth: 3
                    });
                });
            }

            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: rideName,
                            color: '#fff',
                            font: { size: 16 }
                        },
                        legend: {
                            labels: { color: '#fff' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: xTicksConfig2,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: xAxisTitle,
                                color: '#a0a0a0',
                                font: { size: 16, weight: 'bold' }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: { color: '#a0a0a0', font: { size: 14, weight: 'bold' } },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            title: {
                                display: true,
                                text: '待ち時間（分）',
                                color: '#a0a0a0',
                                font: { size: 16, weight: 'bold' }
                            }
                        }
                    }
                }
            });
        }

        /** 詳細画面の時系列テーブル（日付・時刻・待ち時間）を描画する */
        function renderTable(rideData) {
            const tbody = document.querySelector('#dataTable tbody');
            if (!tbody) return;
            
            tbody.innerHTML = '';
            const reversedData = [...rideData].reverse();

            for (const d of reversedData) {
                const waitClass = getWaitClass(d.wait_time);
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${d.time}</td>
                    <td>${d.is_open ? '🟢 運営中' : '⚫ 休止中'}</td>
                    <td class="${waitClass}">${d.is_open ? d.wait_time + '分' : '-'}</td>
                `;
                tbody.appendChild(tr);
            }
        }

        /** 表示用：待ち時間を5分刻みに丸める（0, 5, 10, 15, ...） */
        function roundTo5(n) {
            if (n == null || n === '' || isNaN(n)) return n;
            const v = Number(n);
            return Math.round(v / 5) * 5;
        }

        function getWaitClass(waitTime) {
            // park-data.js で定義した共通ロジックを利用
            return getWaitClassGlobal(waitTime);
        }

        function backToList() {
            currentDetailRideId = null;
            const headerBtn = document.getElementById('headerBackToListBtn');
            if (headerBtn) headerBtn.style.display = 'none';
            showAllRides();
        }

        /** 文字列をHTMLエスケープして返す */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ── 前回の来園日と比較 ──
        /** 現在表示中の日付（日ビュー時は selectedValue 等）。YYYY-MM-DD または null */
        function getCurrentViewingDate() {
            if (!loadedData) return null;
            if (loadedData.dateRange && loadedData.dateRange.length > 0) return loadedData.dateRange[0];
            if (loadedData.selectedValue) return loadedData.selectedValue;
            if (loadedData.date) return loadedData.date;
            return null;
        }

        /** 指定年・月の日数を返す（month は 1〜12 の文字列または数値） */
        function getDaysInMonth(year, month) {
            return new Date(parseInt(year, 10), parseInt(month, 10), 0).getDate();
        }

        /** 日付比較用の日選択肢を、選択中の年・月に合わせて更新する */
        function updateCompareDayOptions() {
            const yearSelect = document.getElementById('compareYear');
            const monthSelect = document.getElementById('compareMonth');
            const daySelect = document.getElementById('compareDay');
            if (!yearSelect || !monthSelect || !daySelect) return;
            const year = yearSelect.value;
            const month = monthSelect.value;
            if (!year || !month) return;
            const lastDay = getDaysInMonth(year, month);
            const currentDay = parseInt(daySelect.value, 10) || 1;
            daySelect.innerHTML = '';
            for (let d = 1; d <= lastDay; d++) {
                const opt = document.createElement('option');
                opt.value = d;
                opt.textContent = d + '日';
                if (d === Math.min(currentDay, lastDay)) opt.selected = true;
                daySelect.appendChild(opt);
            }
        }

        /** 現在の日本時間の年・月・日を返す（{ year, month, day }） */
        function getJstDate() {
            const now = new Date();
            const ymd = now.toLocaleDateString('en-CA', { timeZone: 'Asia/Tokyo' });
            const [y, m, d] = ymd.split('-');
            return { year: parseInt(y, 10), month: m, day: d };
        }

        /** 日付比較モーダルを開き、年・月・日の選択UIを表示する */
        function openCompareModal() {
            if (currentPeriod !== 'day' || !loadedData) return;
            const jst = getJstDate();
            const currentYear = jst.year;
            const currentMonth = jst.month;
            const currentDay = jst.day;
            const yearOptions = [];
            for (let y = currentYear; y >= currentYear - 3; y--) {
                yearOptions.push(`<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}年</option>`);
            }
            const monthOptions = Array.from({ length: 12 }, (_, i) => {
                const v = String(i + 1).padStart(2, '0');
                return `<option value="${v}" ${v === currentMonth ? 'selected' : ''}>${i + 1}月</option>`;
            }).join('');
            const dayOptions = Array.from({ length: 31 }, (_, i) => {
                const v = String(i + 1).padStart(2, '0');
                return `<option value="${v}" ${v === currentDay ? 'selected' : ''}>${i + 1}日</option>`;
            }).join('');
            const body = document.getElementById('compareModalBody');
            body.innerHTML = `
                <div class="compare-controls">
                    <label>前回行った日：</label>
                    <select id="compareYear">${yearOptions.join('')}</select>
                    <select id="compareMonth">${monthOptions}</select>
                    <select id="compareDay">${dayOptions}</select>
                </div>
                <p class="compare-note">過去365日以外の日付は、その日のデータのみ取得して比較します。</p>
                <button type="button" class="compare-run-btn" id="compareRunBtn">比較する</button>
                <div id="compareResult"></div>
            `;
            updateCompareDayOptions();
            const compareYear = document.getElementById('compareYear');
            const compareMonth = document.getElementById('compareMonth');
            if (compareYear) compareYear.addEventListener('change', updateCompareDayOptions);
            if (compareMonth) compareMonth.addEventListener('change', updateCompareDayOptions);
            document.getElementById('compareRunBtn').addEventListener('click', runCompare);
            document.getElementById('compareOverlay').style.display = 'flex';
        }

        /** 日付比較モーダルを閉じる */
        function closeCompareModal() {
            document.getElementById('compareOverlay').style.display = 'none';
        }

        /** モーダル背景クリックで比較モーダルを閉じる */
        function closeCompareOverlay(event) {
            if (event.target === document.getElementById('compareOverlay')) {
                closeCompareModal();
            }
        }

        // ── 週末 vs 平日比較 ──
        /** dateStr (YYYY-MM-DD) の曜日を JST で取得。0=日, 6=土 */
        function getDayOfWeekJst(dateStr) {
            const d = new Date(dateStr + 'T12:00:00+09:00');
            return d.getUTCDay();
        }

        /** 現在の JST 時刻の「時」（0〜23）を返す */
        function getJstHour() {
            const formatter = new Intl.DateTimeFormat('ja-JP', { timeZone: 'Asia/Tokyo', hour: 'numeric', hour12: false });
            return parseInt(formatter.format(new Date()), 10) || 0;
        }

        /** 基準日と同じ曜日の日付を、利用可能な日付から過去向きに最大 maxWeeks 件返す（古い順） */
        function getSameWeekdayDates(refDateStr, maxWeeks) {
            if (!refDateStr || !availableDates.length) return [];
            const refDow = getDayOfWeekJst(refDateStr);
            const sameWeekday = availableDates.filter(d => d <= refDateStr && getDayOfWeekJst(d) === refDow);
            sameWeekday.sort();
            return sameWeekday.slice(-maxWeeks);
        }

        const SPARKLINE_WEEKS = 5;
        const SPARKLINE_TARGET_HOUR = null; // null = 現在時刻で自動

        /**
         * 指定した各日付について、targetHour 時台のスナップショットから待ち時間を取得し、
         * rideId -> [wait1, wait2, ...] と labels を返す
         */
        async function fetchSparklineData(parkId, targetHour, dateStrings) {
            const byRide = new Map();
            const labels = [];
            const hour = targetHour != null ? targetHour : getJstHour();
            const timePrefix = String(hour).padStart(2, '0') + ':';

            for (const dateStr of dateStrings) {
                const data = await fetchSupabaseDataForDate(parkId, dateStr);
                if (!data || !data.records || data.records.length === 0) {
                    labels.push(dateStr.slice(5).replace('-', '/'));
                    continue;
                }
                const rec = data.records.find(r => (r.time || '').startsWith(timePrefix)) || data.records.find(r => (r.time || '').startsWith(String(hour)));
                labels.push(dateStr.slice(5).replace('-', '/'));

                if (rec && rec.rides) {
                    for (const ride of rec.rides) {
                        if (!byRide.has(ride.id)) byRide.set(ride.id, []);
                        const arr = byRide.get(ride.id);
                        const wait = (ride.is_open && ride.wait_time > 0) ? ride.wait_time : null;
                        arr.push(wait);
                    }
                }
                for (const [, arr] of byRide) {
                    while (arr.length < labels.length) arr.push(null);
                }
            }
            return { byRide, labels };
        }

        /** スパークラインを canvas に描画する。values と labels は同じ長さ */
        function drawSparkline(container, values, labels, options) {
            if (!container || !Array.isArray(values)) return;
            const validValues = values.filter(v => v != null && !isNaN(v));
            if (validValues.length === 0) return;

            const height = (options && options.height) || 36;
            const padding = { top: 4, right: 4, bottom: 4, left: 4 };
            const w = container.offsetWidth || 200;
            const h = height;
            const innerW = Math.max(0, w - padding.left - padding.right);
            const innerH = Math.max(0, h - padding.top - padding.bottom);

            let canvas = container.querySelector('canvas');
            if (!canvas) {
                canvas = document.createElement('canvas');
                canvas.setAttribute('role', 'img');
                container.appendChild(canvas);
            }
            const dpr = window.devicePixelRatio || 1;
            canvas.width = w * dpr;
            canvas.height = h * dpr;
            canvas.style.width = w + 'px';
            canvas.style.height = h + 'px';
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);

            const minV = Math.min(...validValues);
            const maxV = Math.max(...validValues);
            const range = maxV - minV || 1;
            const n = values.length;
            const stepX = n > 1 ? innerW / (n - 1) : 0;

            ctx.clearRect(0, 0, w, h);
            ctx.strokeStyle = options && options.strokeStyle ? options.strokeStyle : 'rgba(78, 205, 196, 0.9)';
            ctx.fillStyle = options && options.fillStyle ? options.fillStyle : 'rgba(78, 205, 196, 0.15)';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';

            const points = [];
            for (let i = 0; i < n; i++) {
                const x = padding.left + (n > 1 ? i * stepX : innerW / 2);
                const v = values[i];
                const y = v != null && !isNaN(v)
                    ? padding.top + innerH - ((v - minV) / range) * innerH
                    : null;
                points.push({ x, y });
            }
            const validPoints = points.filter(p => p.y !== null);
            if (validPoints.length < 2) return;

            ctx.beginPath();
            ctx.moveTo(validPoints[0].x, validPoints[0].y);
            for (let i = 1; i < validPoints.length; i++) {
                ctx.lineTo(validPoints[i].x, validPoints[i].y);
            }
            ctx.stroke();
            ctx.lineTo(validPoints[validPoints.length - 1].x, padding.top + innerH);
            ctx.lineTo(validPoints[0].x, padding.top + innerH);
            ctx.closePath();
            ctx.fill();
        }

        /** 一覧表示後に、各カード用のスパークラインデータを取得して描画する */
        /** 一覧の各カードに、同じ曜日の過去数週間のスパークラインを非同期で描画する */
        async function loadAndDrawListSparklines() {
            const content = document.getElementById('content');
            if (!content || !loadedData || !USE_SUPABASE || availableDates.length === 0) return;

            let refDateStr = null;
            if (currentPeriod === 'day' && loadedData && loadedData.selectedValue) {
                refDateStr = loadedData.selectedValue;
            } else {
                const jst = getJstDate();
                refDateStr = `${jst.year}-${jst.month}-${jst.day}`;
            }
            if (!refDateStr || !availableDates.includes(refDateStr)) {
                if (availableDates.length > 0) refDateStr = availableDates[0];
            }
            if (!refDateStr) return;

            const dateStrings = getSameWeekdayDates(refDateStr, SPARKLINE_WEEKS);
            if (dateStrings.length < 2) return;

            const targetHour = SPARKLINE_TARGET_HOUR != null ? SPARKLINE_TARGET_HOUR : getJstHour();
            const { byRide, labels } = await fetchSparklineData(currentPark, targetHour, dateStrings);

            const wraps = content.querySelectorAll('.sparkline-wrap[data-ride-id]');
            wraps.forEach(wrap => {
                const rideId = parseInt(wrap.dataset.rideId, 10);
                if (isNaN(rideId)) return;
                const arr = byRide.get(rideId);
                if (!arr || arr.every(v => v == null)) return;
                const canvasWrap = wrap.querySelector('.sparkline-canvas-wrap');
                if (canvasWrap) drawSparkline(canvasWrap, arr, labels, { height: 36 });
            });
        }

        /** 詳細画面用：1アトラクションの「同じ時間帯の過去○週間」を取得して描画 */
        /** 詳細画面のスパークライン（同じ曜日・同時間帯の過去推移）を取得・描画する */
        async function loadDetailSparkline(rideId) {
            const section = document.getElementById('detailSparklineSection');
            const canvasWrap = document.getElementById('detailSparklineCanvas');
            if (!section || !canvasWrap || !USE_SUPABASE || availableDates.length === 0) return;

            let refDateStr = null;
            if (currentPeriod === 'day' && loadedData && loadedData.selectedValue) {
                refDateStr = loadedData.selectedValue;
            } else {
                const jst = getJstDate();
                refDateStr = `${jst.year}-${jst.month}-${jst.day}`;
            }
            if (!refDateStr && availableDates.length > 0) refDateStr = availableDates[0];
            if (!refDateStr) return;

            const dateStrings = getSameWeekdayDates(refDateStr, SPARKLINE_WEEKS);
            if (dateStrings.length < 2) {
                section.style.display = 'none';
                return;
            }

            const targetHour = SPARKLINE_TARGET_HOUR != null ? SPARKLINE_TARGET_HOUR : getJstHour();
            const { byRide, labels } = await fetchSparklineData(currentPark, targetHour, dateStrings);
            const arr = byRide.get(rideId);
            if (!arr || arr.every(v => v == null)) {
                section.style.display = 'none';
                return;
            }
            section.style.display = 'block';
            const titleEl = section.querySelector('.sparkline-title');
            if (titleEl) titleEl.textContent = `📈 ${targetHour}時台の過去${dateStrings.length}週間の推移（同じ曜日）`;
            drawSparkline(canvasWrap, arr, labels, { height: 80 });
        }

        function closeWeekendWeekdayOverlay(event) {
            const overlay = document.getElementById('weekendWeekdayOverlay');
            if (!overlay) return;
            if (event && event.target !== overlay && !(event.target.closest && event.target.closest('#weekendWeekdayModalClose'))) return;
            overlay.style.display = 'none';
        }

        /** 土日 vs 平日の比較モーダルを開き、両方の平均待ち時間を計算して表示する */
        async function openWeekendWeekdayModal() {
            const body = document.getElementById('weekendWeekdayModalBody');
            if (!body) return;
            body.innerHTML = '<div class="loading"><div class="spinner"></div><p>週末・平日のデータを取得中...</p></div>';
            document.getElementById('weekendWeekdayOverlay').style.display = 'flex';

            const MAX_DAYS_EACH = 5;
            const weekendDates = [];
            const weekdayDates = [];
            for (const dateStr of availableDates) {
                const day = getDayOfWeekJst(dateStr);
                if (day === 0 || day === 6) {
                    if (weekendDates.length < MAX_DAYS_EACH) weekendDates.push(dateStr);
                } else {
                    if (weekdayDates.length < MAX_DAYS_EACH) weekdayDates.push(dateStr);
                }
                if (weekendDates.length >= MAX_DAYS_EACH && weekdayDates.length >= MAX_DAYS_EACH) break;
            }

            if (weekendDates.length === 0 || weekdayDates.length === 0) {
                body.innerHTML = '<div class="compare-no-data">週末または平日のデータが足りません。もう少し履歴がたまると比較できます。</div>';
                return;
            }

            try {
                const fetchWeekend = weekendDates.map(d => fetchSupabaseDataForDate(currentPark, d));
                const fetchWeekday = weekdayDates.map(d => fetchSupabaseDataForDate(currentPark, d));
                const weekendResults = await Promise.all(fetchWeekend);
                const weekdayResults = await Promise.all(fetchWeekday);

                const weekendWaits = new Map(); // rideId -> [wait, ...]
                const weekdayWaits = new Map();
                for (const data of weekendResults) {
                    if (!data || !data.records) continue;
                    for (const record of data.records) {
                        for (const ride of record.rides) {
                            if (ride.is_open && ride.wait_time > 0) {
                                const key = String(ride.id);
                                if (!weekendWaits.has(key)) weekendWaits.set(key, []);
                                weekendWaits.get(key).push(ride.wait_time);
                            }
                        }
                    }
                }
                for (const data of weekdayResults) {
                    if (!data || !data.records) continue;
                    for (const record of data.records) {
                        for (const ride of record.rides) {
                            if (ride.is_open && ride.wait_time > 0) {
                                const key = String(ride.id);
                                if (!weekdayWaits.has(key)) weekdayWaits.set(key, []);
                                weekdayWaits.get(key).push(ride.wait_time);
                            }
                        }
                    }
                }

                const allRideIds = new Set([...weekendWaits.keys(), ...weekdayWaits.keys()]);
                const rowData = [];
                for (const rideId of allRideIds) {
                    const name = getRideName(parseInt(rideId, 10), '');
                    const wkWaits = weekendWaits.get(rideId) || [];
                    const wdWaits = weekdayWaits.get(rideId) || [];
                    const wkAvg = wkWaits.length > 0 ? roundTo5(wkWaits.reduce((a, b) => a + b, 0) / wkWaits.length) : null;
                    const wkMax = wkWaits.length > 0 ? Math.max(...wkWaits) : null;
                    const wdAvg = wdWaits.length > 0 ? roundTo5(wdWaits.reduce((a, b) => a + b, 0) / wdWaits.length) : null;
                    const wdMax = wdWaits.length > 0 ? Math.max(...wdWaits) : null;
                    rowData.push({
                        name,
                        weekendAvg: wkAvg,
                        weekendMax: wkMax,
                        weekdayAvg: wdAvg,
                        weekdayMax: wdMax
                    });
                }
                rowData.sort((a, b) => a.name.localeCompare(b.name, 'ja'));

                const rows = rowData.map(r => {
                    const wkAvgStr = r.weekendAvg != null ? r.weekendAvg + '分' : '-';
                    const wkMaxStr = r.weekendMax != null ? r.weekendMax + '分' : '-';
                    const wdAvgStr = r.weekdayAvg != null ? r.weekdayAvg + '分' : '-';
                    const wdMaxStr = r.weekdayMax != null ? r.weekdayMax + '分' : '-';
                    return `<tr><td class="compare-table-ride-name">${escapeHtml(r.name)}</td><td>${wkAvgStr}</td><td>${wkMaxStr}</td><td>${wdAvgStr}</td><td>${wdMaxStr}</td></tr>`;
                });

                const tableHtml = `
                    <p class="compare-note">直近の週末${weekendDates.length}日分・平日${weekdayDates.length}日分のデータで比較しています。</p>
                    <div class="compare-table-wrapper">
                        <table class="compare-table">
                            <thead><tr><th>アトラクション</th><th>週末 平均</th><th>週末 最大</th><th>平日 平均</th><th>平日 最大</th></tr></thead>
                            <tbody>${rows.join('')}</tbody>
                        </table>
                    </div>
                `;
                body.innerHTML = tableHtml;
            } catch (e) {
                console.error(e);
                body.innerHTML = '<div class="compare-no-data">比較の取得中にエラーが発生しました。</div>';
            }
        }

        /** スマホ表示時、ヒートマップの横スクロールを現在時刻の列の位置に合わせる */
        function scrollHeatmapToCurrentTime(container) {
            if (!window.matchMedia('(max-width: 768px)').matches) return;
            const root = container && container.nodeType === 1 ? container : document;
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('ja-JP', { timeZone: 'Asia/Tokyo', hour: 'numeric', minute: 'numeric', hour12: false });
            const parts = formatter.formatToParts(now);
            const hour = parseInt(parts.find(p => p.type === 'hour').value, 10) || 0;
            const minute = parseInt(parts.find(p => p.type === 'minute').value, 10) || 0;
            // 9:00〜21:00 を30分刻み → スロット index 0〜24。範囲外の場合は先頭または末尾へ
            let slotIndex = (hour - 9) * 2 + (minute >= 30 ? 1 : 0);
            const beforeRange = slotIndex < 0;   // 9:00より前
            const afterRange = slotIndex > 24;  // 21:00より後
            if (beforeRange) slotIndex = 0;
            if (afterRange) slotIndex = 24;
            const thIndex = slotIndex + 1;

            root.querySelectorAll('.heatmap-table-wrapper').forEach(wrapper => {
                requestAnimationFrame(() => {
                    if (beforeRange) {
                        wrapper.scrollLeft = 0;
                        return;
                    }
                    if (afterRange) {
                        wrapper.scrollLeft = Math.max(0, wrapper.scrollWidth - wrapper.clientWidth);
                        return;
                    }
                    const table = wrapper.querySelector('.heatmap-table');
                    if (!table) return;
                    const headerRow = table.querySelector('thead tr');
                    if (!headerRow) return;
                    const ths = headerRow.querySelectorAll('th');
                    if (ths.length <= thIndex) return;
                    const th = ths[thIndex];
                    if (!th) return;
                    const thCenter = th.offsetLeft + th.offsetWidth / 2;
                    const viewportCenter = wrapper.clientWidth * 0.75;
                    const targetScroll = thCenter - viewportCenter;
                    wrapper.scrollLeft = Math.max(0, Math.min(wrapper.scrollWidth - wrapper.clientWidth, targetScroll));
                });
            });
        }

        function renderCompareSection() {
            const baseDate = getCurrentViewingDate();
            if (!baseDate) return '';
            const jst = getJstDate();
            const currentYear = jst.year;
            const currentMonth = jst.month;
            const currentDay = jst.day;
            const yearOptions = [];
            for (let y = currentYear; y >= currentYear - 3; y--) {
                yearOptions.push(`<option value="${y}" ${y === currentYear ? 'selected' : ''}>${y}年</option>`);
            }
            const monthOptions = Array.from({ length: 12 }, (_, i) => {
                const v = String(i + 1).padStart(2, '0');
                return `<option value="${v}" ${v === currentMonth ? 'selected' : ''}>${i + 1}月</option>`;
            }).join('');
            const dayOptions = Array.from({ length: 31 }, (_, i) => {
                const v = String(i + 1).padStart(2, '0');
                return `<option value="${v}" ${v === currentDay ? 'selected' : ''}>${i + 1}日</option>`;
            }).join('');
            return `
                <div class="compare-section">
                    <div class="compare-section-title">📅 前回の来園日と比較</div>
                    <div class="compare-controls">
                        <label>前回行った日：</label>
                        <select id="compareYear">${yearOptions}</select>
                        <select id="compareMonth">${monthOptions}</select>
                        <select id="compareDay">${dayOptions}</select>
                    </div>
                    <p class="compare-note">過去365日以外の日付は、その日のデータのみ取得して比較します。ヘッダーの「前回の来園日と比較」で比較します。</p>
                    <div id="compareResult"></div>
                </div>
            `;
        }

        /** 指定日の履歴データを取得する（Supabase またはローカル） */
        async function fetchHistoryDataForDate(dateStr) {
            if (!dateStr || !currentPark) return null;
            if (USE_SUPABASE) return await fetchSupabaseDataForDate(currentPark, dateStr);
            return null;
        }

        /** 1日分の records からアトラクション別・パーク全体の待ち時間統計を計算する */
        function computeDayStats(records) {
            const rideWaits = new Map();
            let parkSum = 0;
            let parkCount = 0;
            for (const record of records) {
                for (const ride of record.rides) {
                    if (ride.is_open && ride.wait_time > 0) {
                        const key = String(ride.id);
                        if (!rideWaits.has(key)) rideWaits.set(key, []);
                        rideWaits.get(key).push(ride.wait_time);
                        parkSum += ride.wait_time;
                        parkCount++;
                    }
                }
            }
            const rideAvg = new Map();
            rideWaits.forEach((waits, id) => {
                const avg = waits.reduce((a, b) => a + b, 0) / waits.length;
                rideAvg.set(id, roundTo5(avg));
            });
            const parkAvg = parkCount > 0 ? roundTo5(parkSum / parkCount) : 0;
            return { rideAvg, parkAvg };
        }

        /** 比較モーダルの年・月・日入力から YYYY-MM-DD を組み立てて返す */
        function getCompareDateFromInputs() {
            const y = document.getElementById('compareYear');
            const m = document.getElementById('compareMonth');
            const d = document.getElementById('compareDay');
            if (!y || !m || !d || !y.value || !m.value || !d.value) return null;
            return `${y.value}-${String(m.value).padStart(2, '0')}-${String(d.value).padStart(2, '0')}`;
        }

        /** 選択した「前回の来園日」と表示中の日付の待ち時間を比較し、結果を表示する */
        async function runCompare() {
            const resultEl = document.getElementById('compareResult');
            const btnEl = document.getElementById('compareRunBtn') || document.getElementById('compareBtn');
            if (!resultEl || !loadedData) return;
            const compareDate = getCompareDateFromInputs();
            if (!compareDate) {
                resultEl.innerHTML = '<div class="compare-no-data">年・月・日を選択してください。</div>';
                return;
            }
            const baseDate = getCurrentViewingDate();
            if (baseDate === compareDate) {
                resultEl.innerHTML = '<div class="compare-no-data">基準日と別の日を選択してください。</div>';
                return;
            }
            const today = new Date();
            const jstToday = new Date(today.getTime() + (9 * 60 * 60 * 1000));
            const todayStr = jstToday.toISOString().split('T')[0];
            if (compareDate > todayStr) {
                resultEl.innerHTML = '<div class="compare-no-data">前回の来園日は今日以前の日付を選択してください。</div>';
                return;
            }
            if (btnEl) {
                btnEl.disabled = true;
            }
            resultEl.innerHTML = '';
            try {
                const compareData = await fetchHistoryDataForDate(compareDate);
                if (!compareData || !compareData.records.length) {
                    resultEl.innerHTML = '<div class="compare-no-data">前回の日のデータを読み込めませんでした。</div>';
                    return;
                }
                const baseStats = computeDayStats(loadedData.records);
                const compareStats = computeDayStats(compareData.records);
                const onlyRideId = currentDetailRideId != null ? String(currentDetailRideId) : null;
                const allRideIds = onlyRideId
                    ? new Set([onlyRideId])
                    : new Set([...baseStats.rideAvg.keys(), ...compareStats.rideAvg.keys()]);
                const rowData = [];
                for (const rideId of allRideIds) {
                    const name = getRideName(parseInt(rideId, 10), '');
                    const baseAvg = baseStats.rideAvg.get(rideId);
                    const compareAvg = compareStats.rideAvg.get(rideId);
                    if (baseAvg == null && compareAvg == null) continue;
                    const baseStr = baseAvg != null ? baseAvg + '分' : '-';
                    const compareStr = compareAvg != null ? compareAvg + '分' : '-';
                    let diffHtml = '-';
                    let diffClass = 'compare-diff-same';
                    if (baseAvg != null && compareAvg != null) {
                        const diff = baseAvg - compareAvg;
                        const diffRounded = roundTo5(Math.abs(diff));
                        if (diffRounded === 0) {
                            diffHtml = '±0分';
                        } else if (diff > 0) {
                            diffClass = 'compare-diff-more';
                            diffHtml = '+' + diffRounded + '分';
                        } else {
                            diffClass = 'compare-diff-less';
                            diffHtml = '-' + diffRounded + '分';
                        }
                    }
                    rowData.push({ name, baseStr, compareStr, diffHtml, diffClass });
                }
                rowData.sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                const rows = rowData.map(r => `<tr><td>${escapeHtml(r.name)}</td><td>${r.baseStr}</td><td>${r.compareStr}</td><td class="${r.diffClass}">${r.diffHtml}</td></tr>`);
                let summaryHtml;
                if (onlyRideId) {
                    if (rowData.length > 0) {
                        const r = rowData[0];
                        const baseVal = baseStats.rideAvg.get(onlyRideId);
                        const compareVal = compareStats.rideAvg.get(onlyRideId);
                        const diff = baseVal != null && compareVal != null ? baseVal - compareVal : 0;
                        const diffRounded = roundTo5(Math.abs(diff));
                        let summaryClass = 'same';
                        let summaryText = '';
                        if (diffRounded === 0) {
                            summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）とほぼ同じ待ち時間でした。`;
                        } else if (diff > 0) {
                            summaryClass = 'more';
                            summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）より 平均 ${diffRounded}分長いです`;
                        } else {
                            summaryClass = 'less';
                            summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）より 平均 ${diffRounded}分短いです`;
                        }
                        summaryHtml = `<div class="compare-summary ${summaryClass}">${summaryText}</div>`;
                    } else {
                        summaryHtml = '<div class="compare-no-data">今回・前回のいずれにもこのアトラクションのデータがありません。</div>';
                    }
                } else {
                    // 表と同じ「アトラクション別の差」の平均でサマリを出す（表と一致させる）
                    const diffs = [];
                    for (const rideId of allRideIds) {
                        const baseAvg = baseStats.rideAvg.get(rideId);
                        const compareAvg = compareStats.rideAvg.get(rideId);
                        if (baseAvg != null && compareAvg != null) {
                            diffs.push(baseAvg - compareAvg);
                        }
                    }
                    const avgDiff = diffs.length > 0 ? diffs.reduce((a, b) => a + b, 0) / diffs.length : 0;
                    const avgDiffRounded = roundTo5(Math.abs(avgDiff));
                    let summaryClass = 'same';
                    let summaryText = '';
                    if (diffs.length === 0) {
                        summaryText = '今回・前回の両方にデータがあるアトラクションがありません。';
                    } else if (avgDiffRounded === 0) {
                        summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）とほぼ同じ待ち時間です。`;
                    } else if (avgDiff > 0) {
                        summaryClass = 'more';
                        summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）より 平均 ${avgDiffRounded}分長いです`;
                    } else {
                        summaryClass = 'less';
                        summaryText = `前回（${formatDateForPeriod(compareDate, 'day')}）より 平均 ${avgDiffRounded}分短いです`;
                    }
                    summaryHtml = `<div class="compare-summary ${summaryClass}">${summaryText}</div>`;
                }
                const tableHtml = rowData.length > 0 ? `
                    <div class="compare-table-wrapper">
                        <table class="compare-table">
                            <thead><tr><th>アトラクション</th><th>今回</th><th>前回</th><th>差</th></tr></thead>
                            <tbody>${rows.join('')}</tbody>
                        </table>
                    </div>
                ` : '';
                resultEl.innerHTML = summaryHtml + tableHtml;
            } catch (e) {
                resultEl.innerHTML = '<div class="compare-no-data">比較中にエラーが発生しました。</div>';
            } finally {
                if (btnEl) {
                    btnEl.disabled = false;
                    btnEl.textContent = btnEl.id === 'compareRunBtn' ? '比較する' : '📅 比較';
                }
            }
        }

        /** グラフの点クリック時に、そのポイントの候補アトラクションをポップアップで表示する */
        function showPointPopup(candidates, event) {
            // 既存のポップアップがあれば削除
            const existing = document.getElementById('pointPopupOverlay');
            if (existing) {
                existing.remove();
            }

            const overlay = document.createElement('div');
            overlay.id = 'pointPopupOverlay';
            overlay.className = 'point-popup-overlay';

            const popup = document.createElement('div');
            popup.className = 'point-popup';

            const header = document.createElement('div');
            header.className = 'point-popup-header';
            const title = document.createElement('div');
            title.className = 'point-popup-title';
            title.textContent = 'アトラクションを選択';
            const closeBtn = document.createElement('button');
            closeBtn.className = 'point-popup-close';
            closeBtn.type = 'button';
            closeBtn.textContent = '×';
            closeBtn.addEventListener('click', () => overlay.remove());

            header.appendChild(title);
            header.appendChild(closeBtn);

            const list = document.createElement('div');
            list.className = 'point-popup-list';

            candidates.forEach(c => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'point-popup-item';

                const main = document.createElement('div');
                main.className = 'point-popup-item-main';
                const name = document.createElement('span');
                name.className = 'point-popup-item-name';
                name.textContent = c.name;
                const wait = document.createElement('span');
                wait.textContent = `${c.wait}分`;

                const meta = document.createElement('div');
                meta.className = 'point-popup-item-meta';
                meta.textContent = c.timeLabel;

                main.appendChild(name);
                main.appendChild(wait);
                item.appendChild(main);
                item.appendChild(meta);

                item.addEventListener('click', () => {
                    showRideDetail(c.rideId);
                    overlay.remove();
                });

                list.appendChild(item);
            });

            popup.appendChild(header);
            popup.appendChild(list);
            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // アトラクション名が1行に収まるよう、リスト内で最も幅の広い要素に合わせて横幅を調整
            let maxItemWidth = 0;
            const mains = list.querySelectorAll('.point-popup-item-main');
            mains.forEach(el => {
                const w = el.scrollWidth;
                if (w > maxItemWidth) maxItemWidth = w;
            });
            // 名前＋待ち時間の行に十分な余白を持たせつつ、画面幅に収まるようにする
            const horizontalPadding = 80; // 左右パディング＋余裕を少し大きめに
            const targetWidth = Math.min(maxItemWidth + horizontalPadding, window.innerWidth - 24);
            if (targetWidth > 0) {
                popup.style.width = `${targetWidth}px`;
            }

            // 高さを全候補がスクロールなしでちょうど収まるように調整
            // まず自動レイアウトさせてから、実際のコンテンツ高さ(scrollHeight)を採用する
            popup.style.height = 'auto';
            list.style.maxHeight = 'none';
            const headerRect = header.getBoundingClientRect();
            const listContentHeight = list.scrollHeight; // ボタン同士の余白も含めた実高さ
            const verticalPadding = 40; // 上下の余裕分（少し多めにして余白を確保）
            const popupHeight = headerRect.height + listContentHeight + verticalPadding;
            popup.style.height = `${popupHeight}px`;

            // クリック位置がポップアップの中央付近になるよう配置（画面外にはみ出さないよう調整）
            const clickX = event.clientX ?? 0;
            const clickY = event.clientY ?? 0;
            const rect = popup.getBoundingClientRect();

            let left = clickX - rect.width / 2;
            let top = clickY - rect.height / 2;

            const vw = window.innerWidth;

            if (left + rect.width > vw - 8) {
                left = vw - rect.width - 8;
            }

            if (left < 8) left = 8;
            if (top < 8) top = 8;

            popup.style.left = `${left}px`;
            popup.style.top = `${top}px`;

            // オーバーレイ背景クリックで閉じる（ポップアップ内クリックは除外）
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
        }

        // 期間タブのイベントリスナー
        document.querySelectorAll('.period-tab').forEach(tab => {
            tab.addEventListener('click', async () => {
                document.querySelectorAll('.period-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentPeriod = tab.dataset.period;
                selectedAreas = [];
                await updateDateSelectOptions();
            });
        });

        // 日付選択のイベントリスナー
        document.getElementById('dateSelect').addEventListener('change', async (e) => {
            if (e.target.value) {
                selectedAreas = []; // エリア選択をリセット（すべて選択）
                await loadPeriodData(e.target.value);
            }
        });

        async function jumpToDay(dateStr) {
            // 「日」タブをアクティブにする
            document.querySelectorAll('.period-tab').forEach(t => t.classList.remove('active'));
            const dayTab = document.querySelector('.period-tab[data-period="day"]');
            if (dayTab) {
                dayTab.classList.add('active');
            }

            currentPeriod = 'day';
            selectedAreas = [];

            const dateSelect = document.getElementById('dateSelect');

            // 日付セレクトに目的の日付がなければ、日ビュー用に再構築
            if (!Array.from(dateSelect.options).some(opt => opt.value === dateStr)) {
                await updateDateSelectOptions();
            }

            dateSelect.value = dateStr;
            await loadPeriodData(dateStr);
        }

        // 期間に応じた日付選択オプションを更新
        async function updateDateSelectOptions() {
            const dateSelect = document.getElementById('dateSelect');
            const content = document.getElementById('content');
            
            content.innerHTML = '';

            if (currentPeriod === 'day') {
                // 日単位: 利用可能な日付リスト
                dateSelect.innerHTML = '<option value="">日付を選択...</option>';
                for (const date of availableDates) {
                    const option = document.createElement('option');
                    option.value = date;
                    option.textContent = formatDateForPeriod(date, 'day');
                    dateSelect.appendChild(option);
                }
                if (availableDates.length > 0) {
                    dateSelect.value = availableDates[0];
                    await loadPeriodData(availableDates[0]);
                }
            } else if (currentPeriod === 'week') {
                // 週単位: 週の開始日リスト
                const weeks = getWeekOptions();
                dateSelect.innerHTML = '<option value="">週を選択...</option>';
                for (const week of weeks) {
                    const option = document.createElement('option');
                    option.value = week.start;
                    option.textContent = week.label;
                    dateSelect.appendChild(option);
                }
                if (weeks.length > 0) {
                    dateSelect.value = weeks[0].start;
                    await loadPeriodData(weeks[0].start);
                }
            } else if (currentPeriod === 'month') {
                // 月単位
                const months = getMonthOptions();
                dateSelect.innerHTML = '<option value="">月を選択...</option>';
                for (const month of months) {
                    const option = document.createElement('option');
                    option.value = month.value;
                    option.textContent = month.label;
                    dateSelect.appendChild(option);
                }
                if (months.length > 0) {
                    dateSelect.value = months[0].value;
                    await loadPeriodData(months[0].value);
                }
            } else if (currentPeriod === 'year') {
                // 年単位
                const years = getYearOptions();
                dateSelect.innerHTML = '<option value="">年を選択...</option>';
                for (const year of years) {
                    const option = document.createElement('option');
                    option.value = year;
                    option.textContent = `${year}年`;
                    dateSelect.appendChild(option);
                }
                if (years.length > 0) {
                    dateSelect.value = years[0];
                    await loadPeriodData(years[0]);
                }
            }

        }

        /** 期間（day/week/month/year）に応じて日付ラベルを整形する（イベント表示用） */
        function formatDateForPeriod(dateStr, period) {
            const date = new Date(dateStr);
            if (period === 'day') {
                return date.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' });
            }
            return dateStr;
        }

        /** 週カレンダー用の日付ラベル（例: 2/5(木)）を返す */
        function formatWeekDateLabel(dateStr) {
            const date = new Date(dateStr);
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const weekday = '日月火水木金土'[date.getDay()];
            return `${month}/${day}(${weekday})`;
        }

        /** YYYY-MM-DD をローカル日付（時刻0:00）に変換する */
        function parseDateStringToLocalDate(dateStr) {
            // "YYYY-MM-DD" をローカルタイムの Date に安全に変換（タイムゾーンずれ防止）
            const [y, m, d] = dateStr.split('-').map(Number);
            return new Date(y, m - 1, d);
        }

        /** 訪問サマリー（データ件数・時間帯・イベント情報）の表示用オブジェクトを計算する */
        function computeVisitSummary() {
            if (!loadedData || !loadedData.records || getDisplayedRecords().length === 0) return null;

            const records = getDisplayedRecords();
            const weekdayLabels = ['日', '月', '火', '水', '木', '金', '土'];

            if (currentPeriod === 'week' || currentPeriod === 'month') {
                // 曜日ごとの平均待ち時間（全アトラクション・全スナップショット）
                const stats = Array(7).fill(null).map(() => ({ sum: 0, count: 0 }));

                for (const rec of records) {
                    const date = new Date(rec.date);
                    const dow = date.getDay(); // 0=日
                    for (const ride of rec.rides) {
                        if (ride.is_open && ride.wait_time > 0) {
                            stats[dow].sum += ride.wait_time;
                            stats[dow].count += 1;
                        }
                    }
                }

                const averages = stats
                    .map((s, idx) => (s.count > 0 ? { key: idx, label: `${weekdayLabels[idx]}曜日`, avg: s.sum / s.count } : null))
                    .filter(Boolean)
                    .sort((a, b) => a.avg - b.avg)
                    .slice(0, 3);

                if (!averages.length) return null;

                return {
                    title: currentPeriod === 'week' ? 'この週のおすすめ曜日（短い順）' : 'この月のおすすめ曜日（短い順）',
                    items: averages.map((a, i) => ({
                        rank: i + 1,
                        label: a.label,
                        avgMinutes: roundTo5(a.avg)
                    }))
                };
            }

            if (currentPeriod === 'year') {
                // 月ごとの平均待ち時間
                const monthStats = Array(12).fill(null).map(() => ({ sum: 0, count: 0 }));

                for (const rec of records) {
                    if (!rec.date) continue;
                    const [y, m] = rec.date.split('-');
                    const monthIdx = parseInt(m, 10) - 1;
                    if (monthIdx < 0 || monthIdx > 11) continue;

                    for (const ride of rec.rides) {
                        if (ride.is_open && ride.wait_time > 0) {
                            monthStats[monthIdx].sum += ride.wait_time;
                            monthStats[monthIdx].count += 1;
                        }
                    }
                }

                const averages = monthStats
                    .map((s, idx) => (s.count > 0 ? { key: idx, label: `${idx + 1}月`, avg: s.sum / s.count } : null))
                    .filter(Boolean)
                    .sort((a, b) => a.avg - b.avg)
                    .slice(0, 3);

                if (!averages.length) return null;

                return {
                    title: 'この年のおすすめ月（短い順）',
                    items: averages.map((a, i) => ({
                        rank: i + 1,
                        label: a.label,
                        avgMinutes: roundTo5(a.avg)
                    }))
                };
            }

            return null;
        }

        /**
         * お気に入りアトラクションID一覧を読み込む
         * - ログインしていない場合は「お気に入り機能は使用不可」とし、何も復元しない
         * - ログイン済みなら Supabase の ride_favorites テーブルから取得
         */
        async function loadFavoriteRides() {
            favoriteRideIds = new Set();
            try {
                const client = typeof getHistorySupabaseClient === 'function' ? getHistorySupabaseClient() : null;
                if (!client) return;
                const { data } = await client.auth.getUser();
                const user = data && data.user;
                if (!user) {
                    // 未ログイン時は何も復元しない（お気に入り機能は使用不可）
                    return;
                }

                const { data: rows, error } = await client
                    .from('ride_favorites')
                    .select('ride_id')
                    .eq('user_id', user.id);
                if (error) {
                    console.warn('Failed to load favorites from Supabase (history)', error);
                    return;
                }
                if (Array.isArray(rows)) {
                    favoriteRideIds = new Set(rows.map(r => String(r.ride_id)));
                }
            } catch (e) {
                console.warn('Failed to load favorites from Supabase (history)', e);
            }
        }

        /**
         * お気に入りアトラクションID一覧を保存する
         * - ログインしていない場合は何もしない（使用不可）
         * - ログイン済みなら Supabase の ride_favorites テーブルに保存
         */
        async function saveFavoriteRides() {
            const client = typeof getHistorySupabaseClient === 'function' ? getHistorySupabaseClient() : null;
            if (!client) return;

            try {
                const { data } = await client.auth.getUser();
                const user = data && data.user;
                if (!user) {
                    // 未ログイン時は保存しない
                    return;
                }

                const arr = Array.from(favoriteRideIds).map(id => String(id));

                // シンプルに「そのユーザーのレコードを全削除 → 現在の一覧を insert」
                const { error: delError } = await client
                    .from('ride_favorites')
                    .delete()
                    .eq('user_id', user.id);
                if (delError) {
                    console.warn('Failed to delete favorites on Supabase (history)', delError);
                }

                if (arr.length > 0) {
                    const rows = arr.map(rideId => ({
                        user_id: user.id,
                        ride_id: String(rideId)
                    }));
                    const { error: insError } = await client
                        .from('ride_favorites')
                        .insert(rows);
                    if (insError) {
                        console.warn('Failed to save favorites to Supabase (history)', insError);
                    }
                }
            } catch (e) {
                console.warn('Failed to save favorites to Supabase (history)', e);
            }
        }

        function showFavLoginModal(messageOverride) {
            const overlay = document.getElementById('favLoginOverlay');
            const msgEl = document.querySelector('#favLoginOverlay .fav-login-message');
            if (msgEl && messageOverride) {
                msgEl.innerHTML = messageOverride;
            } else if (msgEl) {
                msgEl.innerHTML = 'お気に入り機能を使うには、Google アカウントでログインしてください。<br>ログインすると、端末をまたいでお気に入りを共有できます。';
            }
            if (overlay) overlay.style.display = 'flex';
        }

        function hideFavLoginModal() {
            const overlay = document.getElementById('favLoginOverlay');
            if (overlay) overlay.style.display = 'none';
        }

        async function loginFromFavModal() {
            hideFavLoginModal();
            // 履歴画面の「Googleでログイン」と同じ処理を呼び出す
            if (typeof handleHistoryGoogleLoginClick === 'function') {
                await handleHistoryGoogleLoginClick();
            }
        }

        /** お気に入りの追加/解除をトグルし、保存する（未ログインならモーダル表示して何もしない） */
        async function toggleFavoriteRide(rideId) {
            const client = typeof getHistorySupabaseClient === 'function' ? getHistorySupabaseClient() : null;
            if (!client) {
                showFavLoginModal('Supabase の設定が行われていないため、お気に入り機能は利用できません。<br>管理者にお問い合わせください。');
                return;
            }

            try {
                const { data } = await client.auth.getUser();
                const user = data && data.user;
                if (!user) {
                    showFavLoginModal();
                    return;
                }
            } catch (e) {
                console.warn('Failed to check auth state for favorites (history)', e);
                showFavLoginModal('現在、お気に入り機能を利用できません。<br>時間をおいて再度お試しください。');
                return;
            }

            const key = String(rideId);
            if (favoriteRideIds.has(key)) {
                favoriteRideIds.delete(key);
            } else {
                favoriteRideIds.add(key);
            }
            // 非同期で保存（結果は待たずに UI を先に更新）
            saveFavoriteRides();
        }

        /** 週選択用のオプション（日曜始まりの週のラベル一覧）を返す */
        function getWeekOptions() {
            const weeks = [];
            const seenWeeks = new Set();
            
            for (const dateStr of availableDates) {
                const date = new Date(dateStr);
                const dayOfWeek = date.getDay(); // 日曜=0
                const sunday = new Date(date);
                sunday.setDate(date.getDate() - dayOfWeek); // その週の日曜日
                const weekStart = sunday.toISOString().split('T')[0];
                
                if (!seenWeeks.has(weekStart)) {
                    seenWeeks.add(weekStart);
                    const saturday = new Date(sunday);
                    saturday.setDate(sunday.getDate() + 6);
                    weeks.push({
                        start: weekStart,
                        label: `${sunday.getMonth() + 1}/${sunday.getDate()}(日) 〜 ${saturday.getMonth() + 1}/${saturday.getDate()}(土)`
                    });
                }
            }
            return weeks;
        }

        /** 月選択用のオプション（YYYY-MM と表示ラベル）を返す */
        function getMonthOptions() {
            const months = [];
            const seenMonths = new Set();
            
            for (const dateStr of availableDates) {
                const [year, month] = dateStr.split('-');
                const monthKey = `${year}-${month}`;
                
                if (!seenMonths.has(monthKey)) {
                    seenMonths.add(monthKey);
                    months.push({
                        value: monthKey,
                        label: `${year}年${parseInt(month)}月`
                    });
                }
            }
            return months;
        }

        /** 年選択用のオプション（利用可能な年のリスト）を返す */
        function getYearOptions() {
            const years = new Set();
            for (const dateStr of availableDates) {
                years.add(dateStr.split('-')[0]);
            }
            return [...years].sort().reverse();
        }

        // --- ここから Supabase Auth（history.html 用） ---

        let historySupabaseClient = null;

        function getHistorySupabaseClient() {
            if (historySupabaseClient) return historySupabaseClient;
            if (!window.SUPABASE_URL || !window.SUPABASE_ANON_KEY || typeof window.supabase === 'undefined') {
                console.warn('Supabase Auth が正しく設定されていません。supabase-config.js と CDN スクリプトを確認してください。');
                return null;
            }
            const { createClient } = window.supabase;
            historySupabaseClient = createClient(window.SUPABASE_URL, window.SUPABASE_ANON_KEY);
            return historySupabaseClient;
        }

        async function updateHistoryAuthUI() {
            const mainContainer = document.getElementById('historyMainContainer');
            const chipDesktop = document.getElementById('historyAuthStatusChipDesktop');
            const loginBtnDesktop = document.getElementById('historyGoogleLoginBtnDesktop');
            const logoutBtnDesktop = document.getElementById('historyLogoutBtnDesktop');
            const chipMobile = document.getElementById('historyAuthStatusChipMobile');
            const loginBtnMobile = document.getElementById('historyGoogleLoginBtnMobile');
            const logoutBtnMobile = document.getElementById('historyLogoutBtnMobile');

            if (!mainContainer) return;

            const client = getHistorySupabaseClient();
            if (!client) {
                // 認証クライアントが作れない場合は index.html と同様に「認証未設定」表示
                mainContainer.style.display = '';
                if (chipDesktop) chipDesktop.innerHTML = '<span>認証未設定</span>';
                if (chipMobile) chipMobile.innerHTML = '<span>認証未設定</span>';
                if (loginBtnDesktop) loginBtnDesktop.style.display = 'none';
                if (logoutBtnDesktop) logoutBtnDesktop.style.display = 'none';
                if (loginBtnMobile) loginBtnMobile.style.display = 'none';
                if (logoutBtnMobile) logoutBtnMobile.style.display = 'none';
                return;
            }

            try {
                const { data, error } = await client.auth.getUser();
                if (error) {
                    console.error('getUser error', error);
                }
                if (data && data.user) {
                    const user = data.user;
                    // 先に管理者フラグを更新してからバッジの表示を決める
                    await refreshHistoryEventAdminState();
                    mainContainer.style.display = '';
                    const meta = user.user_metadata || {};
                    const avatarUrl = meta.avatar_url || meta.picture || null;
                    const rawName = (meta.full_name || meta.name)
                        || (user.email ? user.email.split('@')[0] : 'ログイン中');
                    const safeName = escapeHtml(rawName);
                    const badgeHtml = isHistoryEventAdmin
                        ? '<span class="auth-role-badge">管理者</span>'
                        : '';
                    const iconHtml = avatarUrl
                        ? `<img src="${escapeHtml(avatarUrl)}" class="auth-user-avatar" alt="profile" />`
                        : '<span class="auth-user-icon">👤</span>';
                    const html = `${iconHtml}<span class="auth-user-name">${safeName}</span>${badgeHtml}`;
                    if (chipDesktop) {
                        chipDesktop.innerHTML = html;
                        chipDesktop.style.display = '';
                    }
                    if (chipMobile) {
                        chipMobile.innerHTML = html;
                        chipMobile.style.display = '';
                    }
                    if (loginBtnDesktop) loginBtnDesktop.style.display = 'none';
                    if (logoutBtnDesktop) logoutBtnDesktop.style.display = '';
                    if (loginBtnMobile) loginBtnMobile.style.display = 'none';
                    if (logoutBtnMobile) logoutBtnMobile.style.display = '';
                } else {
                    // ログアウト状態ではお気に入り情報をリセット
                    favoriteRideIds = new Set();
                    showFavoritesOnly = false;
                    mainContainer.style.display = '';
                    if (chipDesktop) {
                        chipDesktop.innerHTML = '';
                        chipDesktop.style.display = 'none';
                    }
                    if (chipMobile) {
                        chipMobile.innerHTML = '';
                        chipMobile.style.display = 'none';
                    }
                    if (loginBtnDesktop) loginBtnDesktop.style.display = '';
                    if (logoutBtnDesktop) logoutBtnDesktop.style.display = 'none';
                    if (loginBtnMobile) loginBtnMobile.style.display = '';
                    if (logoutBtnMobile) logoutBtnMobile.style.display = 'none';
                    // ログアウト状態ではイベント管理者フラグをクリア
                    isHistoryEventAdmin = false;
                    updateEventManageButtonVisibility();
                }
            } catch (err) {
                console.error('updateHistoryAuthUI error', err);
                mainContainer.style.display = '';
                if (chipDesktop) chipDesktop.innerHTML = '<span>認証状態の確認に失敗しました</span>';
                if (chipMobile) chipMobile.innerHTML = '<span>認証状態の確認に失敗しました</span>';
                if (loginBtnDesktop) loginBtnDesktop.style.display = '';
                if (logoutBtnDesktop) logoutBtnDesktop.style.display = 'none';
                if (loginBtnMobile) loginBtnMobile.style.display = '';
                if (logoutBtnMobile) logoutBtnMobile.style.display = 'none';
            }
        }

        async function handleHistoryGoogleLoginClick() {
            const statusEl = document.getElementById('historyAuthStatus'); // なくてもよい（存在する場合のみメッセージ表示）
            const loginBtnDesktop = document.getElementById('historyGoogleLoginBtnDesktop');
            const loginBtnMobile = document.getElementById('historyGoogleLoginBtnMobile');

            const client = getHistorySupabaseClient();
            if (!client) return;

            if (loginBtnDesktop) loginBtnDesktop.disabled = true;
            if (loginBtnMobile) loginBtnMobile.disabled = true;
            if (statusEl) {
                statusEl.textContent = 'Google のログイン画面にリダイレクトします...';
                statusEl.classList.remove('error');
                statusEl.classList.remove('success');
            }

            try {
                // ローカル開発と GitHub Pages でリダイレクト先を出し分ける
                let redirectTo;
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    // ローカル: ルート (http://localhost:3000) に戻す
                    redirectTo = window.location.origin;
                } else if (window.location.origin.includes('github.io')) {
                    // GitHub Pages: リポジトリルートに戻す
                    redirectTo = window.location.origin + '/disney-wait-time/';
                } else {
                    // それ以外のホストでは従来通り index.html に戻す
                    redirectTo = window.location.origin + '/index.html';
                }

                const { error } = await client.auth.signInWithOAuth({
                    provider: 'google',
                    options: {
                        // ログイン完了後にトップ画面へ遷移させる
                        redirectTo,
                        queryParams: { prompt: 'select_account' }
                    }
                });
                if (error) {
                    console.error('signInWithOAuth (google) error', error);
                    if (statusEl) {
                        statusEl.textContent = error.message || 'Google ログインに失敗しました。';
                        statusEl.classList.remove('success');
                        statusEl.classList.add('error');
                    }
                    if (loginBtnDesktop) loginBtnDesktop.disabled = false;
                    if (loginBtnMobile) loginBtnMobile.disabled = false;
                    return;
                }
                // 通常はここで Supabase によりリダイレクトされる
            } catch (err) {
                console.error('handleHistoryGoogleLoginClick error', err);
                if (statusEl) {
                    statusEl.textContent = '予期しないエラーが発生しました。時間をおいて再度お試しください。';
                    statusEl.classList.remove('success');
                    statusEl.classList.add('error');
                }
                if (loginBtnDesktop) loginBtnDesktop.disabled = false;
                if (loginBtnMobile) loginBtnMobile.disabled = false;
            }
        }

        async function handleHistoryLogoutClick() {
            const client = getHistorySupabaseClient();
            if (!client) return;
            const logoutBtnDesktop = document.getElementById('historyLogoutBtnDesktop');
            const logoutBtnMobile = document.getElementById('historyLogoutBtnMobile');
            if (logoutBtnDesktop) logoutBtnDesktop.disabled = true;
            if (logoutBtnMobile) logoutBtnMobile.disabled = true;
            try {
                await client.auth.signOut();
            } catch (e) {
                console.error('handleHistoryLogoutClick error', e);
            } finally {
                // ログアウトしたらお気に入り状態をリセット
                favoriteRideIds = new Set();
                showFavoritesOnly = false;
                if (logoutBtnDesktop) logoutBtnDesktop.disabled = false;
                if (logoutBtnMobile) logoutBtnMobile.disabled = false;
                updateHistoryAuthUI();
                // ログアウトしたらトップのランド/シー選択画面（index.html）へ戻す
                window.location.href = 'index.html';
            }
        }

        function handleHistoryBackWithoutLogin() {
            const params = new URLSearchParams(window.location.search);
            const park = params.get('park');
            if (park) {
                window.location.href = `index.html?park=${encodeURIComponent(park)}`;
            } else {
                window.location.href = 'index.html';
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            const googleBtnDesktop = document.getElementById('historyGoogleLoginBtnDesktop');
            const googleBtnMobile = document.getElementById('historyGoogleLoginBtnMobile');
            const logoutBtnDesktop = document.getElementById('historyLogoutBtnDesktop');
            const logoutBtnMobile = document.getElementById('historyLogoutBtnMobile');
            const backWithoutLoginBtn = document.getElementById('historyBackWithoutLoginButton');
            if (googleBtnDesktop) {
                googleBtnDesktop.addEventListener('click', handleHistoryGoogleLoginClick);
            }
            if (googleBtnMobile) {
                googleBtnMobile.addEventListener('click', handleHistoryGoogleLoginClick);
            }
            if (logoutBtnDesktop) {
                logoutBtnDesktop.addEventListener('click', handleHistoryLogoutClick);
            }
            if (logoutBtnMobile) {
                logoutBtnMobile.addEventListener('click', handleHistoryLogoutClick);
            }
            if (backWithoutLoginBtn) {
                backWithoutLoginBtn.addEventListener('click', handleHistoryBackWithoutLogin);
            }
            updateHistoryAuthUI();
        });

        // 期間に応じたデータを読み込み
        async function loadPeriodData(value) {
            const parkInfo = PARKS[currentPark];
            const content = document.getElementById('content');
            
            content.innerHTML = '';

            try {
                let datesToLoad = [];
                
                if (currentPeriod === 'day') {
                    datesToLoad = [value];
                } else if (currentPeriod === 'week') {
                    // 週の日曜日から土曜日まで
                    const sunday = new Date(value);
                    for (let i = 0; i < 7; i++) {
                        const d = new Date(sunday);
                        d.setDate(sunday.getDate() + i);
                        datesToLoad.push(d.toISOString().split('T')[0]);
                    }
                } else if (currentPeriod === 'month') {
                    // 月の全日
                    const [year, month] = value.split('-');
                    const firstDay = new Date(year, parseInt(month) - 1, 1);
                    const lastDay = new Date(year, parseInt(month), 0);
                    for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
                        datesToLoad.push(d.toISOString().split('T')[0]);
                    }
                } else if (currentPeriod === 'year') {
                    // 年の全日（利用可能な日付のみ）
                    datesToLoad = availableDates.filter(d => d.startsWith(value));
                }

                // 利用可能な日付のみフィルタ
                datesToLoad = datesToLoad.filter(d => availableDates.includes(d));

                if (datesToLoad.length === 0) {
                    content.innerHTML = `
                        <div class="no-data">
                            <h2>データがありません</h2>
                            <p>選択した期間のデータが見つかりませんでした。</p>
                        </div>
                    `;
                    return;
                }

                // Supabase から複数日のデータを読み込んで統合
                const allRecords = [];
                for (const date of datesToLoad) {
                    const data = await fetchSupabaseDataForDate(currentPark, date);
                    if (data && data.records) {
                        for (const record of data.records) {
                            allRecords.push({
                                date: record.date,
                                time: record.time,
                                timestamp: record.timestamp,
                                rides: record.rides
                            });
                        }
                    }
                }

                loadedData = {
                    park: parkInfo.name,
                    period: currentPeriod,
                    selectedValue: value,  // 選択された値（月の場合は"YYYY-MM"）
                    dateRange: datesToLoad,
                    records: allRecords
                };

                // アトラクション個別画面を維持（期間/日付変更時）
                if (currentDetailRideId !== null) {
                    showRideDetail(currentDetailRideId);
                } else {
                    showAllRides();
                }

                // URLパラメータでrideが指定されていれば詳細表示（初回のみ）
                if (!initialRideHandled && rideParam) {
                    initialRideHandled = true;
                    const rideId = parseInt(rideParam);
                    if (rideId) {
                        showRideDetail(rideId);
                    }
                }

            } catch (error) {
                console.error('Error:', error);
                content.innerHTML = `
                    <div class="error">
                        <h3>データの読み込みに失敗しました</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>
